# Redis集群故障转移中的写入暂停与恢复流程

在Redis集群的故障转移过程中，特别是在手动故障转移(CLUSTER FAILOVER)时，为了保证数据一致性，会暂停原主节点的写入操作。本文详细说明这一暂停与恢复的完整流程。

## 写入暂停与恢复的总体流程

1. **客户端写入暂停**：原主节点暂停处理客户端写入请求
2. **数据同步**：确保从节点数据与主节点同步
3. **角色转换**：从节点晋升为新主节点，原主节点降级为从节点
4. **写入恢复**：新主节点恢复客户端写入处理

## 详细流程说明

### 1. 写入暂停阶段

当从节点接收到`CLUSTER FAILOVER`命令后：

* 从节点向主节点发送MFSTART消息，请求主节点暂停客户端写操作
* 主节点接收到MFSTART消息后，调用`pauseClients()`函数
* `pauseClients()`函数会：
  - 设置服务器状态为CLIENT_PAUSE_WRITE（或更严格的CLIENT_PAUSE_ALL）
  - 记录暂停开始时间
  - 客户端的写入命令将被延迟处理（放入队列）而不是直接执行

```c
// 简化的pauseClients函数实现
void pauseClients(int pause_type, mstime_t end) {
    server.client_pause_type = pause_type;
    server.client_pause_end_time = end;
    // 延迟处理后续写入请求
}
```

### 2. 已暂停写入请求的处理

被暂停的客户端请求有三种处理方式：

* **队列化**：将请求放入队列，等待暂停结束后处理
* **错误返回**：对某些请求返回错误（如"WRITE PAUSED"）
* **有限延迟**：如果暂停时间过长，可能会导致部分客户端连接超时断开

在主节点的事件循环中，会检查每个客户端请求是否可以处理：

```c
// 简化的client请求处理检查
int clientsArePaused(void) {
    if (server.client_pause_type == CLIENT_PAUSE_OFF) return 0;
    if (server.client_pause_end_time && server.client_pause_end_time < server.mstime) {
        // 暂停时间已过，解除暂停
        unpauseClients();
        return 0;
    }
    return 1; // 仍在暂停中
}
```

### 3. 角色转换期间的请求处理

在故障转移过程中，角色转换关键时刻的请求处理：

* 当原主节点发现自己不再是主节点时：
  - 会检测到配置纪元(epoch)变化
  - 发现自己负责的槽位被分配给了其他节点
  - 将自己的角色从主节点转变为从节点
  - 关闭所有与旧槽位相关的请求处理

* 原主节点转变为从节点后：
  - 会与新主节点建立复制连接
  - 此时客户端写入仍然处于暂停状态
  - 任何写入请求会被重定向到新主节点

### 4. 写入恢复阶段

故障转移完成后，写入恢复有两种情况：

#### 4.1 新主节点的写入恢复

* 新主节点完成晋升后，会接受集群的写入请求
* 如果是手动故障转移，新主节点会调用`unpauseClients()`恢复客户端写入处理
* 新主节点开始接受所有重定向过来的写请求

```c
// 简化的unpauseClients函数实现
void unpauseClients(void) {
    server.client_pause_type = CLIENT_PAUSE_OFF;
    server.client_pause_end_time = 0;
    // 处理队列中累积的请求
    processQueuedClientRequests();
}
```

#### 4.2 旧主节点（现从节点）的处理

* 原主节点变为从节点后：
  - 仍保持写入暂停状态一段时间
  - 等待与新主节点建立复制关系
  - 当它完成与新主节点的初始同步后，会自动解除暂停状态
  - 后续收到的写请求会返回MOVED重定向错误，指向新主节点

### 5. 客户端重连与重定向

在故障转移完成后：

* 客户端会收到MOVED重定向错误
* 客户端会更新自己的槽位映射缓存
* 客户端重新发送请求到新的主节点
* 对于持久连接的客户端，可能需要重新建立连接

## 暂停机制的实现细节

Redis的客户端暂停机制实现在networking.c文件中：

* `pauseClients()`: 暂停客户端请求处理
* `unpauseClients()`: 恢复客户端请求处理
* `clientsArePaused()`: 检查客户端是否处于暂停状态
* `processInputBuffer()`: 处理客户端请求时会检查暂停状态

## 故障转移超时与暂停恢复

如果故障转移过程中断或超时：

* 有全局超时控制，避免客户端无限期暂停
* 默认情况下，即使故障转移失败，也会在一定时间后自动解除暂停
* 集群状态更新后，所有节点都会重新评估自己的角色

## 与异步复制的关系

Redis使用异步复制机制，在故障转移过程中：

* 标准手动故障转移会等待复制偏移量赶上
* 这确保了旧主节点暂停后的所有写入都被新主节点同步
* 当确认数据一致后，才会完成角色转换和恢复写入

通过这种机制，Redis集群确保了在故障转移过程中数据的一致性和可用性的平衡。 