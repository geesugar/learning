# SVG‰ºòÂåñ‰∏éÂ∑•Á®ãÂåñ

SVGÁöÑÂ∑•Á®ãÂåñÂ∫îÁî®ÈúÄË¶ÅËÄÉËôëËá™Âä®ÂåñÂ∑•ÂÖ∑Èìæ„ÄÅÊÄßËÉΩ‰ºòÂåñ„ÄÅÂõ¢ÈòüÂçè‰ΩúÁ≠âÂ§ö‰∏™ÊñπÈù¢„ÄÇÊú¨Á´†Â∞ÜÊ∑±ÂÖ•Êé¢ËÆ®Â¶Ç‰ΩïÂú®Áé∞‰ª£ÂºÄÂèëÂ∑•‰ΩúÊµÅ‰∏≠È´òÊïàÂú∞‰ΩøÁî®SVGÊäÄÊúØ„ÄÇ

## üéØ Â≠¶‰π†ÁõÆÊ†á

ÂÆåÊàêÊú¨Á´†Â≠¶‰π†ÂêéÔºåÊÇ®Â∞ÜËÉΩÂ§üÔºö
- Âª∫Á´ãÂÆåÊï¥ÁöÑSVGËá™Âä®ÂåñÂ∑•‰ΩúÊµÅ
- ÊéåÊè°ÂêÑÁßçSVG‰ºòÂåñÂ∑•ÂÖ∑ÂíåÊäÄÊúØ
- ÈõÜÊàêSVGÂà∞Áé∞‰ª£ÊûÑÂª∫Á≥ªÁªü
- ÂÆûÁé∞SVGÁöÑÁâàÊú¨ÁÆ°ÁêÜÂíåÂõ¢ÈòüÂçè‰Ωú
- ÊûÑÂª∫ÂèØÁª¥Êä§ÁöÑSVGÈ°πÁõÆÊû∂ÊûÑ

## üõ†Ô∏è Ëá™Âä®ÂåñÂ∑•ÂÖ∑Èìæ

### SVGO‰ºòÂåñÂ∑•ÂÖ∑

```bash
# ÂÆâË£ÖSVGO
npm install -g svgo

# Âü∫Êú¨‰ºòÂåñ
svgo input.svg -o output.svg

# ÊâπÈáè‰ºòÂåñ
svgo -f ./icons -o ./optimized-icons

# Ëá™ÂÆö‰πâÈÖçÁΩÆ
svgo --config svgo.config.js input.svg
```

```javascript
// svgo.config.js
module.exports = {
  plugins: [
    {
      name: 'preset-default',
      params: {
        overrides: {
          // ‰øùÁïôviewBox
          removeViewBox: false,
          // ‰øùÁïôIDÁî®‰∫éÂºïÁî®
          cleanupIDs: {
            remove: false,
            minify: false
          }
        }
      }
    },
    // Ëá™ÂÆö‰πâÊèí‰ª∂
    {
      name: 'customPlugin',
      fn: () => {
        return {
          element: {
            enter: (node, parentNode) => {
              // Ëá™ÂÆö‰πâ‰ºòÂåñÈÄªËæë
              if (node.name === 'rect' && node.attributes.width === '0') {
                // ÁßªÈô§ÂÆΩÂ∫¶‰∏∫0ÁöÑÁü©ÂΩ¢
                parentNode.children = parentNode.children.filter(child => child !== node);
              }
            }
          }
        };
      }
    }
  ]
};
```

### WebpackÈõÜÊàê

```javascript
// webpack.config.js
const path = require('path');

module.exports = {
  module: {
    rules: [
      {
        test: /\.svg$/,
        use: [
          {
            loader: '@svgr/webpack',
            options: {
              svgoConfig: {
                plugins: [
                  {
                    name: 'preset-default',
                    params: {
                      overrides: {
                        removeViewBox: false,
                      },
                    },
                  },
                ],
              },
            },
          },
          {
            loader: 'url-loader',
            options: {
              limit: 8192,
              fallback: 'file-loader',
              name: 'images/[name].[hash:8].[ext]',
            },
          },
        ],
      },
    ],
  },
  plugins: [
    // SVG SpriteÊèí‰ª∂
    new SVGSpritePlugin({
      src: path.resolve(__dirname, 'src/icons'),
      filename: 'icons-sprite.svg',
      svgo: {
        plugins: [
          { removeTitle: true },
          { removeDesc: true },
          { removeComments: true }
        ]
      }
    })
  ]
};
```

### GulpËá™Âä®ÂåñÊµÅÁ®ã

```javascript
// gulpfile.js
const gulp = require('gulp');
const svgmin = require('gulp-svgmin');
const svgstore = require('gulp-svgstore');
const rename = require('gulp-rename');
const cheerio = require('gulp-cheerio');

// SVG‰ºòÂåñ‰ªªÂä°
gulp.task('svg-optimize', () => {
  return gulp.src('src/icons/*.svg')
    .pipe(svgmin({
      plugins: [
        { removeTitle: true },
        { removeDesc: true },
        { removeComments: true },
        { removeMetadata: true },
        { removeEditorsNSData: true },
        { cleanupAttrs: true },
        { mergeStyles: true },
        { inlineStyles: true }
      ]
    }))
    .pipe(gulp.dest('dist/icons'));
});

// SVG SpriteÁîüÊàê
gulp.task('svg-sprite', () => {
  return gulp.src('src/icons/*.svg')
    .pipe(svgmin())
    .pipe(svgstore({ inlineSvg: true }))
    .pipe(cheerio({
      run: function($) {
        // Ê∑ªÂä†Ê†∑ÂºèÈöêËóèsprite
        $('svg').attr('style', 'position: absolute; width: 0; height: 0; overflow: hidden;');
        // ‰∏∫ÊØè‰∏™symbolÊ∑ªÂä†viewBox
        $('symbol').each(function() {
          const $symbol = $(this);
          if (!$symbol.attr('viewBox')) {
            $symbol.attr('viewBox', '0 0 24 24');
          }
        });
      },
      parserOptions: { xmlMode: true }
    }))
    .pipe(rename('icons-sprite.svg'))
    .pipe(gulp.dest('dist'));
});

// ÁõëÂê¨Êñá‰ª∂ÂèòÂåñ
gulp.task('watch', () => {
  gulp.watch('src/icons/*.svg', gulp.series('svg-optimize', 'svg-sprite'));
});

// ÈªòËÆ§‰ªªÂä°
gulp.task('default', gulp.series('svg-optimize', 'svg-sprite', 'watch'));
```

## üì¶ ÂõæÊ†áÁ≥ªÁªüÂ∑•Á®ãÂåñ

### ÂõæÊ†áÁªÑ‰ª∂Âåñ

```javascript
// IconComponent.js
import React from 'react';
import PropTypes from 'prop-types';

// ÂõæÊ†áÊò†Â∞ÑË°®
const iconMap = {
  home: () => import('./icons/home.svg'),
  user: () => import('./icons/user.svg'),
  settings: () => import('./icons/settings.svg'),
  // ... Êõ¥Â§öÂõæÊ†á
};

class Icon extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      SvgComponent: null,
      loading: true,
      error: null
    };
  }
  
  async componentDidMount() {
    await this.loadIcon();
  }
  
  async componentDidUpdate(prevProps) {
    if (prevProps.name !== this.props.name) {
      await this.loadIcon();
    }
  }
  
  async loadIcon() {
    const { name } = this.props;
    
    try {
      this.setState({ loading: true, error: null });
      
      if (iconMap[name]) {
        const module = await iconMap[name]();
        this.setState({
          SvgComponent: module.default || module.ReactComponent,
          loading: false
        });
      } else {
        throw new Error(`Icon "${name}" not found`);
      }
    } catch (error) {
      this.setState({
        error: error.message,
        loading: false
      });
    }
  }
  
  render() {
    const { 
      name, 
      size = 24, 
      color = 'currentColor', 
      className = '',
      style = {},
      ...rest 
    } = this.props;
    
    const { SvgComponent, loading, error } = this.state;
    
    if (loading) {
      return <span className={`icon-loading ${className}`}>‚è≥</span>;
    }
    
    if (error) {
      console.warn(`Icon loading error:`, error);
      return <span className={`icon-error ${className}`}>‚ùå</span>;
    }
    
    if (!SvgComponent) {
      return null;
    }
    
    const iconStyle = {
      width: size,
      height: size,
      fill: color,
      display: 'inline-block',
      ...style
    };
    
    return (
      <SvgComponent 
        className={`icon icon-${name} ${className}`}
        style={iconStyle}
        {...rest}
      />
    );
  }
}

Icon.propTypes = {
  name: PropTypes.string.isRequired,
  size: PropTypes.oneOfType([PropTypes.number, PropTypes.string]),
  color: PropTypes.string,
  className: PropTypes.string,
  style: PropTypes.object
};

export default Icon;

// ‰ΩøÁî®Á§∫‰æã
// <Icon name="home" size={32} color="#3498db" />
```

### ÂõæÊ†áÁÆ°ÁêÜÁ≥ªÁªü

```javascript
// IconManager.js
class IconManager {
  constructor() {
    this.icons = new Map();
    this.cache = new Map();
    this.observers = new Set();
    this.baseUrl = '/icons/';
  }
  
  // Ê≥®ÂÜåÂõæÊ†á
  register(name, config) {
    this.icons.set(name, {
      name,
      url: config.url || `${this.baseUrl}${name}.svg`,
      metadata: config.metadata || {},
      categories: config.categories || [],
      tags: config.tags || [],
      version: config.version || '1.0.0'
    });
    
    this.notifyObservers('register', { name, config });
  }
  
  // ÊâπÈáèÊ≥®ÂÜå
  registerBatch(iconConfigs) {
    iconConfigs.forEach(config => {
      this.register(config.name, config);
    });
  }
  
  // Ëé∑ÂèñÂõæÊ†á
  async getIcon(name) {
    if (this.cache.has(name)) {
      return this.cache.get(name);
    }
    
    const iconConfig = this.icons.get(name);
    if (!iconConfig) {
      throw new Error(`Icon "${name}" not registered`);
    }
    
    try {
      const response = await fetch(iconConfig.url);
      const svgContent = await response.text();
      
      const iconData = {
        name,
        content: svgContent,
        config: iconConfig,
        loadedAt: new Date().toISOString()
      };
      
      this.cache.set(name, iconData);
      this.notifyObservers('loaded', iconData);
      
      return iconData;
    } catch (error) {
      this.notifyObservers('error', { name, error: error.message });
      throw error;
    }
  }
  
  // È¢ÑÂä†ËΩΩÂõæÊ†á
  async preloadIcons(names) {
    const promises = names.map(name => this.getIcon(name).catch(error => {
      console.warn(`Failed to preload icon "${name}":`, error);
      return null;
    }));
    
    const results = await Promise.allSettled(promises);
    const loaded = results.filter(result => result.status === 'fulfilled' && result.value).length;
    
    console.log(`Preloaded ${loaded}/${names.length} icons`);
    return results;
  }
  
  // ÊêúÁ¥¢ÂõæÊ†á
  search(query) {
    const results = [];
    const lowerQuery = query.toLowerCase();
    
    this.icons.forEach((config, name) => {
      const score = this.calculateSearchScore(config, lowerQuery);
      if (score > 0) {
        results.push({ ...config, score });
      }
    });
    
    return results.sort((a, b) => b.score - a.score);
  }
  
  calculateSearchScore(config, query) {
    let score = 0;
    
    // ÂêçÁß∞ÂåπÈÖç
    if (config.name.toLowerCase().includes(query)) {
      score += 10;
    }
    
    // Ê†áÁ≠æÂåπÈÖç
    config.tags.forEach(tag => {
      if (tag.toLowerCase().includes(query)) {
        score += 5;
      }
    });
    
    // ÂàÜÁ±ªÂåπÈÖç
    config.categories.forEach(category => {
      if (category.toLowerCase().includes(query)) {
        score += 3;
      }
    });
    
    return score;
  }
  
  // Ëé∑ÂèñÂõæÊ†áÂàóË°®
  getIconList(filter = {}) {
    const icons = Array.from(this.icons.values());
    
    if (filter.category) {
      return icons.filter(icon => icon.categories.includes(filter.category));
    }
    
    if (filter.tag) {
      return icons.filter(icon => icon.tags.includes(filter.tag));
    }
    
    return icons;
  }
  
  // Ëé∑ÂèñÂàÜÁ±ªÂàóË°®
  getCategories() {
    const categories = new Set();
    this.icons.forEach(icon => {
      icon.categories.forEach(category => categories.add(category));
    });
    return Array.from(categories);
  }
  
  // Ëé∑ÂèñÊ†áÁ≠æÂàóË°®
  getTags() {
    const tags = new Set();
    this.icons.forEach(icon => {
      icon.tags.forEach(tag => tags.add(tag));
    });
    return Array.from(tags);
  }
  
  // Ê∏ÖÁêÜÁºìÂ≠ò
  clearCache() {
    this.cache.clear();
    this.notifyObservers('cache-cleared');
  }
  
  // ËßÇÂØüËÄÖÊ®°Âºè
  subscribe(observer) {
    this.observers.add(observer);
    return () => this.observers.delete(observer);
  }
  
  notifyObservers(event, data) {
    this.observers.forEach(observer => {
      if (typeof observer === 'function') {
        observer(event, data);
      } else if (observer[event]) {
        observer[event](data);
      }
    });
  }
  
  // ÂØºÂá∫ÈÖçÁΩÆ
  exportConfig() {
    const config = {
      icons: Array.from(this.icons.values()),
      version: '1.0.0',
      exportedAt: new Date().toISOString()
    };
    
    return JSON.stringify(config, null, 2);
  }
  
  // ÂØºÂÖ•ÈÖçÁΩÆ
  importConfig(configJson) {
    const config = JSON.parse(configJson);
    
    if (config.icons) {
      this.registerBatch(config.icons);
    }
  }
}

// ÂÖ®Â±ÄÂõæÊ†áÁÆ°ÁêÜÂô®ÂÆû‰æã
const iconManager = new IconManager();

// ÂàùÂßãÂåñÁ§∫‰æãÂõæÊ†á
iconManager.registerBatch([
  {
    name: 'home',
    url: '/icons/home.svg',
    categories: ['navigation'],
    tags: ['house', 'main', 'start'],
    metadata: { author: 'Designer', license: 'MIT' }
  },
  {
    name: 'user',
    url: '/icons/user.svg',
    categories: ['people'],
    tags: ['person', 'profile', 'account'],
    metadata: { author: 'Designer', license: 'MIT' }
  }
]);

export default iconManager;
```

## üîß ÊÄßËÉΩ‰ºòÂåñÁ≠ñÁï•

### SVG‰ª£Á†Å‰ºòÂåñ

```javascript
// SVGOptimizer.js
class SVGOptimizer {
  constructor(options = {}) {
    this.options = {
      removeComments: true,
      removeMetadata: true,
      removeEmptyElements: true,
      mergeStyles: true,
      optimizePaths: true,
      precision: 3,
      ...options
    };
  }
  
  optimize(svgString) {
    let optimized = svgString;
    
    // ÁßªÈô§Ê≥®Èáä
    if (this.options.removeComments) {
      optimized = optimized.replace(/<!--[\s\S]*?-->/g, '');
    }
    
    // ÁßªÈô§ÂÖÉÊï∞ÊçÆ
    if (this.options.removeMetadata) {
      optimized = this.removeMetadata(optimized);
    }
    
    // ÁßªÈô§Á©∫ÂÖÉÁ¥†
    if (this.options.removeEmptyElements) {
      optimized = this.removeEmptyElements(optimized);
    }
    
    // ÂêàÂπ∂Ê†∑Âºè
    if (this.options.mergeStyles) {
      optimized = this.mergeStyles(optimized);
    }
    
    // ‰ºòÂåñË∑ØÂæÑ
    if (this.options.optimizePaths) {
      optimized = this.optimizePaths(optimized);
    }
    
    // ÂéãÁº©Á©∫ÁôΩ
    optimized = this.compressWhitespace(optimized);
    
    return optimized;
  }
  
  removeMetadata(svg) {
    return svg
      .replace(/<title[\s\S]*?<\/title>/gi, '')
      .replace(/<desc[\s\S]*?<\/desc>/gi, '')
      .replace(/<metadata[\s\S]*?<\/metadata>/gi, '');
  }
  
  removeEmptyElements(svg) {
    return svg
      .replace(/<g[^>]*>\s*<\/g>/g, '')
      .replace(/<defs[^>]*>\s*<\/defs>/g, '')
      .replace(/<clipPath[^>]*>\s*<\/clipPath>/g, '');
  }
  
  mergeStyles(svg) {
    const styleRegex = /<style[^>]*>([\s\S]*?)<\/style>/gi;
    const styles = [];
    let match;
    
    while ((match = styleRegex.exec(svg)) !== null) {
      styles.push(match[1]);
    }
    
    if (styles.length > 1) {
      const mergedStyles = styles.join('\\n');
      svg = svg.replace(styleRegex, '');
      svg = svg.replace('<svg', `<style>${mergedStyles}</style><svg`);
    }
    
    return svg;
  }
  
  optimizePaths(svg) {
    const pathRegex = /d="([^"]+)"/g;
    
    return svg.replace(pathRegex, (match, pathData) => {
      const optimizedPath = this.optimizePathData(pathData);
      return `d="${optimizedPath}"`;
    });
  }
  
  optimizePathData(pathData) {
    return pathData
      // ÁßªÈô§Â§ö‰ΩôÁ©∫Ê†º
      .replace(/\s+/g, ' ')
      // ‰ºòÂåñÊï∞Â≠óÁ≤æÂ∫¶
      .replace(/(\d+\.\d{4,})/g, (match) => {
        return parseFloat(match).toFixed(this.options.precision);
      })
      // ÁßªÈô§‰∏çÂøÖË¶ÅÁöÑÈõ∂
      .replace(/(\d)\.0+(\D)/g, '$1$2')
      .replace(/0+(\d)/g, '$1')
      .trim();
  }
  
  compressWhitespace(svg) {
    return svg
      .replace(/>\s+</g, '><')
      .replace(/\s+/g, ' ')
      .trim();
  }
  
  // ÂàÜÊûêSVGÊñá‰ª∂
  analyze(svgString) {
    const analysis = {
      originalSize: svgString.length,
      elements: {},
      attributes: {},
      styles: 0,
      paths: 0
    };
    
    // ÁªüËÆ°ÂÖÉÁ¥†
    const elementRegex = /<(\w+)[^>]*>/g;
    let match;
    while ((match = elementRegex.exec(svgString)) !== null) {
      const tagName = match[1];
      analysis.elements[tagName] = (analysis.elements[tagName] || 0) + 1;
    }
    
    // ÁªüËÆ°Ë∑ØÂæÑ
    analysis.paths = (svgString.match(/d="/g) || []).length;
    
    // ÁªüËÆ°Ê†∑Âºè
    analysis.styles = (svgString.match(/<style/g) || []).length;
    
    return analysis;
  }
}

// ÊâπÈáè‰ºòÂåñÂ∑•ÂÖ∑
class BatchSVGOptimizer {
  constructor(optimizer) {
    this.optimizer = optimizer || new SVGOptimizer();
    this.results = [];
  }
  
  async optimizeFiles(files) {
    this.results = [];
    
    for (const file of files) {
      try {
        const result = await this.optimizeFile(file);
        this.results.push(result);
      } catch (error) {
        this.results.push({
          file: file.name,
          success: false,
          error: error.message
        });
      }
    }
    
    return this.results;
  }
  
  async optimizeFile(file) {
    const originalContent = await this.readFile(file);
    const optimizedContent = this.optimizer.optimize(originalContent);
    
    const originalAnalysis = this.optimizer.analyze(originalContent);
    const optimizedAnalysis = this.optimizer.analyze(optimizedContent);
    
    const compressionRatio = ((originalAnalysis.originalSize - optimizedAnalysis.originalSize) / originalAnalysis.originalSize * 100).toFixed(2);
    
    return {
      file: file.name,
      success: true,
      originalSize: originalAnalysis.originalSize,
      optimizedSize: optimizedAnalysis.originalSize,
      compressionRatio: compressionRatio + '%',
      originalContent,
      optimizedContent
    };
  }
  
  readFile(file) {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = (e) => resolve(e.target.result);
      reader.onerror = reject;
      reader.readAsText(file);
    });
  }
  
  generateReport() {
    const totalOriginalSize = this.results.reduce((sum, result) => 
      sum + (result.originalSize || 0), 0);
    const totalOptimizedSize = this.results.reduce((sum, result) => 
      sum + (result.optimizedSize || 0), 0);
    
    return {
      totalFiles: this.results.length,
      successfulOptimizations: this.results.filter(r => r.success).length,
      totalOriginalSize,
      totalOptimizedSize,
      totalSavings: totalOriginalSize - totalOptimizedSize,
      averageCompressionRatio: ((totalOriginalSize - totalOptimizedSize) / totalOriginalSize * 100).toFixed(2) + '%',
      results: this.results
    };
  }
}

export { SVGOptimizer, BatchSVGOptimizer };
```

## üìä ÁõëÊéßÂíåÂàÜÊûê

### ÊÄßËÉΩÁõëÊéßÁ≥ªÁªü

```javascript
// SVGPerformanceMonitor.js
class SVGPerformanceMonitor {
  constructor() {
    this.metrics = {
      loadTimes: [],
      renderTimes: [],
      memoryUsage: [],
      errorCounts: new Map()
    };
    
    this.observers = new Set();
    this.isMonitoring = false;
  }
  
  startMonitoring() {
    if (this.isMonitoring) return;
    
    this.isMonitoring = true;
    this.setupPerformanceObserver();
    this.setupMemoryMonitoring();
    this.setupErrorTracking();
  }
  
  stopMonitoring() {
    this.isMonitoring = false;
  }
  
  setupPerformanceObserver() {
    if ('PerformanceObserver' in window) {
      const observer = new PerformanceObserver((list) => {
        list.getEntries().forEach(entry => {
          if (entry.name.includes('.svg')) {
            this.recordLoadTime(entry.name, entry.duration);
          }
        });
      });
      
      observer.observe({ entryTypes: ['resource'] });
    }
  }
  
  setupMemoryMonitoring() {
    if (performance.memory) {
      setInterval(() => {
        if (this.isMonitoring) {
          this.recordMemoryUsage();
        }
      }, 5000);
    }
  }
  
  setupErrorTracking() {
    window.addEventListener('error', (event) => {
      if (event.filename && event.filename.includes('.svg')) {
        this.recordError('load-error', event.filename);
      }
    });
  }
  
  recordLoadTime(url, duration) {
    this.metrics.loadTimes.push({
      url,
      duration,
      timestamp: Date.now()
    });
    
    this.notifyObservers('load-time', { url, duration });
  }
  
  recordRenderTime(identifier, duration) {
    this.metrics.renderTimes.push({
      identifier,
      duration,
      timestamp: Date.now()
    });
    
    this.notifyObservers('render-time', { identifier, duration });
  }
  
  recordMemoryUsage() {
    if (performance.memory) {
      const usage = {
        used: performance.memory.usedJSHeapSize,
        total: performance.memory.totalJSHeapSize,
        limit: performance.memory.jsHeapSizeLimit,
        timestamp: Date.now()
      };
      
      this.metrics.memoryUsage.push(usage);
      this.notifyObservers('memory-usage', usage);
    }
  }
  
  recordError(type, details) {
    const count = this.metrics.errorCounts.get(type) || 0;
    this.metrics.errorCounts.set(type, count + 1);
    
    this.notifyObservers('error', { type, details, count: count + 1 });
  }
  
  getReport() {
    const loadTimes = this.metrics.loadTimes;
    const renderTimes = this.metrics.renderTimes;
    
    return {
      summary: {
        totalSVGLoads: loadTimes.length,
        averageLoadTime: this.calculateAverage(loadTimes.map(l => l.duration)),
        maxLoadTime: Math.max(...loadTimes.map(l => l.duration)),
        totalRenders: renderTimes.length,
        averageRenderTime: this.calculateAverage(renderTimes.map(r => r.duration)),
        totalErrors: Array.from(this.metrics.errorCounts.values()).reduce((sum, count) => sum + count, 0)
      },
      details: {
        loadTimes: loadTimes.slice(-100), // ÊúÄËøë100Ê¨°
        renderTimes: renderTimes.slice(-100),
        memoryUsage: this.metrics.memoryUsage.slice(-20), // ÊúÄËøë20Ê¨°
        errorBreakdown: Object.fromEntries(this.metrics.errorCounts)
      },
      recommendations: this.generateRecommendations()
    };
  }
  
  calculateAverage(numbers) {
    if (numbers.length === 0) return 0;
    return numbers.reduce((sum, num) => sum + num, 0) / numbers.length;
  }
  
  generateRecommendations() {
    const recommendations = [];
    const loadTimes = this.metrics.loadTimes;
    
    if (loadTimes.length > 0) {
      const avgLoadTime = this.calculateAverage(loadTimes.map(l => l.duration));
      
      if (avgLoadTime > 100) {
        recommendations.push({
          type: 'performance',
          priority: 'high',
          message: `Âπ≥ÂùáSVGÂä†ËΩΩÊó∂Èó¥ËæÉÈïø(${avgLoadTime.toFixed(2)}ms)ÔºåÂª∫ËÆÆ‰ºòÂåñÊñá‰ª∂Â§ßÂ∞èÊàñ‰ΩøÁî®È¢ÑÂä†ËΩΩ`
        });
      }
      
      const slowLoads = loadTimes.filter(l => l.duration > 200);
      if (slowLoads.length > loadTimes.length * 0.1) {
        recommendations.push({
          type: 'optimization',
          priority: 'medium',
          message: `${slowLoads.length}‰∏™SVGÊñá‰ª∂Âä†ËΩΩËæÉÊÖ¢ÔºåÂª∫ËÆÆËøõË°å‰ºòÂåñ`,
          files: slowLoads.map(l => l.url)
        });
      }
    }
    
    if (this.metrics.errorCounts.size > 0) {
      recommendations.push({
        type: 'reliability',
        priority: 'high',
        message: 'Ê£ÄÊµãÂà∞SVGÂä†ËΩΩÈîôËØØÔºåËØ∑Ê£ÄÊü•Êñá‰ª∂Ë∑ØÂæÑÂíåÁΩëÁªúËøûÊé•',
        errors: Object.fromEntries(this.metrics.errorCounts)
      });
    }
    
    return recommendations;
  }
  
  subscribe(observer) {
    this.observers.add(observer);
    return () => this.observers.delete(observer);
  }
  
  notifyObservers(event, data) {
    this.observers.forEach(observer => {
      if (typeof observer === 'function') {
        observer(event, data);
      } else if (observer[event]) {
        observer[event](data);
      }
    });
  }
  
  exportMetrics() {
    return {
      ...this.metrics,
      exportedAt: new Date().toISOString()
    };
  }
  
  clearMetrics() {
    this.metrics = {
      loadTimes: [],
      renderTimes: [],
      memoryUsage: [],
      errorCounts: new Map()
    };
  }
}

// ÂÖ®Â±ÄÁõëÊéßÂÆû‰æã
const svgMonitor = new SVGPerformanceMonitor();

// Ëá™Âä®ÂêØÂä®ÁõëÊéß
if (typeof window !== 'undefined') {
  svgMonitor.startMonitoring();
}

export default svgMonitor;
```

## üéØ ÊÄªÁªì

SVGÁöÑ‰ºòÂåñ‰∏éÂ∑•Á®ãÂåñÊòØÁé∞‰ª£WebÂºÄÂèë‰∏≠ÁöÑÈáçË¶ÅÁéØËäÇ„ÄÇÈÄöËøáÂª∫Á´ãÂÆåÂñÑÁöÑÂ∑•ÂÖ∑Èìæ„ÄÅÁõëÊéß‰ΩìÁ≥ªÂíåÂõ¢ÈòüÂçè‰ΩúÊµÅÁ®ãÔºåÂèØ‰ª•ÊòæËëóÊèêÂçáSVGÂ∫îÁî®ÁöÑË¥®ÈáèÂíåÁª¥Êä§ÊïàÁéá„ÄÇ

### ÂÖ≥ÈîÆË¶ÅÁÇπÔºö
1. **Âª∫Á´ãËá™Âä®ÂåñÁöÑSVG‰ºòÂåñÂ∑•‰ΩúÊµÅ**
2. **ÂÆûÁé∞ÂèØÁª¥Êä§ÁöÑÂõæÊ†áÁÆ°ÁêÜÁ≥ªÁªü**
3. **ÈõÜÊàêÁé∞‰ª£ÊûÑÂª∫Â∑•ÂÖ∑ÂíåÊµÅÁ®ã**
4. **Âª∫Á´ãÊÄßËÉΩÁõëÊéßÂíåÂàÜÊûê‰ΩìÁ≥ª**
5. **Âà∂ÂÆöÂõ¢ÈòüÂçè‰ΩúÂíåÁâàÊú¨ÁÆ°ÁêÜËßÑËåÉ**

### ÊúÄ‰Ω≥ÂÆûË∑µÔºö
- ‰ΩøÁî®Ê†áÂáÜÂåñÁöÑ‰ºòÂåñÂ∑•ÂÖ∑ÂíåÈÖçÁΩÆ
- Âª∫Á´ãÊ∏ÖÊô∞ÁöÑÊñá‰ª∂ÁªÑÁªáÂíåÂëΩÂêçËßÑËåÉ
- ÂÆûÁé∞Ëá™Âä®ÂåñÁöÑË¥®ÈáèÊ£ÄÊü•ÂíåÊµãËØï
- Êèê‰æõÂÆåÊï¥ÁöÑÊñáÊ°£Âíå‰ΩøÁî®ÊåáÂçó
- Âª∫Á´ãÊåÅÁª≠ÁöÑÊÄßËÉΩÁõëÊéßÂíåÊîπËøõÊú∫Âà∂

ÁªßÁª≠Â≠¶‰π†[È´òÁ∫ßÊäÄÂ∑ß‰∏éÊ°à‰æã](04-advanced-techniques.md)ÔºåÊé¢Á¥¢SVGÂú®Â§çÊùÇÈ°πÁõÆ‰∏≠ÁöÑÈ´òÁ∫ßÂ∫îÁî®ÊäÄÊúØÂíåÂÆûÈôÖÊ°à‰æãÂàÜÊûê„ÄÇ 