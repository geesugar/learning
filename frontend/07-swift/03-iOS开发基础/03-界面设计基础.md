# 界面设计基础

## 📖 概述

界面设计是iOS应用开发的核心环节。本章将深入学习Interface Builder、Storyboard、Auto Layout等iOS界面设计的基础工具和技术，帮你构建美观且适配性强的用户界面。

## 🎯 学习目标

- 熟练使用Interface Builder进行界面设计
- 掌握Storyboard的使用和最佳实践
- 深入理解Auto Layout约束系统
- 学会使用Size Classes实现响应式设计
- 掌握Stack View的高效布局
- 了解动态字体和无障碍设计

## 🎨 Interface Builder 简介

### 什么是Interface Builder

Interface Builder（IB）是Xcode内置的可视化界面设计工具，它允许开发者通过拖拽的方式设计iOS应用的用户界面。

### 核心组件

```
Interface Builder 组成:
┌─────────────────────────────────────────────────────────┐
│                    Canvas (画布)                         │
│  ┌─────────────────────────────────────────────────────┐  │
│  │                                                   │  │
│  │            视图控制器场景                            │  │
│  │                                                   │  │
│  └─────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
│                                                         │
├─ Object Library (对象库)                                │
├─ Inspector Panel (检查器面板)                           │
├─ Document Outline (文档大纲)                            │
└─ Size Inspector (尺寸检查器)                            │
```

### Interface Builder 基本操作

#### 1. 对象库的使用

```swift
// 访问对象库的方法:
// 方法1: View → Show Library
// 方法2: 快捷键 ⇧⌘L
// 方法3: 点击工具栏右上角的 + 按钮

// 常用UI控件:
/*
基础控件:
├── UILabel          // 文本标签
├── UIButton         // 按钮
├── UITextField      // 文本输入框
├── UITextView       // 多行文本
├── UIImageView      // 图片显示
├── UISlider         // 滑块
├── UISwitch         // 开关
├── UISegmentedControl // 分段控制器
└── UIProgressView   // 进度条

容器控件:
├── UIView           // 基础视图
├── UIScrollView     // 滚动视图
├── UIStackView      // 栈视图
├── UITableView      // 表格视图
├── UICollectionView // 集合视图
└── UIContainerView  // 容器视图

导航控件:
├── UINavigationController // 导航控制器
├── UITabBarController     // 标签栏控制器
├── UIPageViewController   // 分页控制器
└── UISplitViewController  // 分屏控制器
*/
```

#### 2. 属性检查器详解

```swift
// 属性检查器面板 (右侧面板)
/*
检查器类型:
┌─────────────────────┐
│ File Inspector      │ // 文件属性
├─────────────────────┤
│ Quick Help          │ // 快速帮助
├─────────────────────┤
│ Identity Inspector  │ // 身份检查器
├─────────────────────┤
│ Attributes Inspector│ // 属性检查器 ⭐
├─────────────────────┤
│ Size Inspector      │ // 尺寸检查器 ⭐
├─────────────────────┤
│ Connections Inspector│ // 连接检查器 ⭐
└─────────────────────┘
*/

// UILabel 属性设置示例:
/*
Attributes Inspector:
├── Text: "Hello World"
├── Color: Label Color
├── Font: System 17.0
├── Alignment: Natural
├── Lines: 1 (0 = 无限制)
├── Line Break: Truncate Tail
├── Baseline: Align Baselines
└── Autoshrink: Fixed Font Size
*/
```

#### 3. 连接代码的方法

```swift
// 创建 IBOutlet 连接:
// 方法1: 右键拖拽控件到代码
// 方法2: Ctrl + 拖拽控件到代码
// 方法3: 在Connections Inspector中手动连接

class ViewController: UIViewController {
    
    // IBOutlet 示例
    @IBOutlet weak var titleLabel: UILabel!
    @IBOutlet weak var nameTextField: UITextField!
    @IBOutlet weak var submitButton: UIButton!
    @IBOutlet weak var profileImageView: UIImageView!
    
    // IBAction 示例
    @IBAction func submitButtonTapped(_ sender: UIButton) {
        // 按钮点击事件处理
        handleSubmit()
    }
    
    @IBAction func textFieldChanged(_ sender: UITextField) {
        // 文本框内容变化处理
        validateInput()
    }
    
    private func handleSubmit() {
        guard let name = nameTextField.text, !name.isEmpty else {
            showAlert(message: "请输入姓名")
            return
        }
        
        titleLabel.text = "欢迎, \(name)!"
    }
    
    private func validateInput() {
        let isValid = !(nameTextField.text?.isEmpty ?? true)
        submitButton.isEnabled = isValid
        submitButton.alpha = isValid ? 1.0 : 0.5
    }
    
    private func showAlert(message: String) {
        let alert = UIAlertController(title: "提示", message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "确定", style: .default))
        present(alert, animated: true)
    }
}
```

## 📱 Storyboard 使用指南

### Storyboard 核心概念

```swift
// Storyboard 组成元素:
/*
Storyboard 结构:
├── Scene (场景)
│   ├── View Controller (视图控制器)
│   ├── Views (视图)
│   └── Constraints (约束)
├── Segue (转场)
│   ├── Show (Push)
│   ├── Show Detail (Replace)
│   ├── Present Modally (Modal)
│   └── Present as Popover (iPad)
└── Exit (退出)
*/
```

### 创建和管理场景

#### 1. 添加新的视图控制器

```swift
// 在Storyboard中添加新场景的步骤:
/*
1. 从对象库拖拽 View Controller 到画布
2. 设置视图控制器的 Class
3. 设置 Storyboard ID (可选，用于代码实例化)
4. 配置界面元素
5. 创建Segue连接
*/

// 程序化实例化视图控制器:
func navigateToDetailView() {
    let storyboard = UIStoryboard(name: "Main", bundle: nil)
    
    // 通过 Storyboard ID 实例化
    if let detailVC = storyboard.instantiateViewController(withIdentifier: "DetailViewController") as? DetailViewController {
        detailVC.data = someData
        navigationController?.pushViewController(detailVC, animated: true)
    }
    
    // 实例化初始视图控制器
    if let initialVC = storyboard.instantiateInitialViewController() {
        present(initialVC, animated: true)
    }
}
```

#### 2. Segue 的使用

```swift
// Segue 类型和使用:

class SourceViewController: UIViewController {
    
    // 准备 Segue
    override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
        switch segue.identifier {
        case "ShowDetailSegue":
            if let detailVC = segue.destination as? DetailViewController {
                detailVC.title = "详情页面"
                detailVC.data = selectedData
            }
            
        case "ShowModalSegue":
            if let modalVC = segue.destination as? ModalViewController {
                modalVC.delegate = self
                modalVC.modalPresentationStyle = .pageSheet
            }
            
        default:
            break
        }
    }
    
    // 程序化触发 Segue
    @IBAction func manualSegueTriggered(_ sender: UIButton) {
        performSegue(withIdentifier: "ShowDetailSegue", sender: sender)
    }
    
    // 条件性 Segue
    override func shouldPerformSegue(withIdentifier identifier: String, sender: Any?) -> Bool {
        if identifier == "ShowDetailSegue" {
            return validateDataBeforeNavigation()
        }
        return true
    }
    
    private func validateDataBeforeNavigation() -> Bool {
        // 验证数据是否有效
        return selectedData != nil
    }
}

// Unwind Segue (返回)
extension SourceViewController {
    
    @IBAction func unwindToSource(_ unwindSegue: UIStoryboardSegue) {
        // 从其他视图控制器返回时的处理
        if let sourceVC = unwindSegue.source as? DetailViewController {
            // 处理返回的数据
            handleReturnedData(sourceVC.modifiedData)
        }
    }
    
    private func handleReturnedData(_ data: Any?) {
        // 处理返回的数据
    }
}
```

### Storyboard 最佳实践

```swift
// 1. 模块化 Storyboard
/*
推荐的 Storyboard 组织方式:
├── Main.storyboard           // 主流程
├── Login.storyboard          // 登录模块
├── Profile.storyboard        // 用户资料模块
├── Settings.storyboard       // 设置模块
└── LaunchScreen.storyboard   // 启动屏幕
*/

// 2. Storyboard References
class StoryboardManager {
    
    static func instantiateLoginFlow() -> UIViewController {
        let storyboard = UIStoryboard(name: "Login", bundle: nil)
        return storyboard.instantiateInitialViewController()!
    }
    
    static func instantiateProfileViewController(for user: User) -> ProfileViewController {
        let storyboard = UIStoryboard(name: "Profile", bundle: nil)
        let profileVC = storyboard.instantiateViewController(withIdentifier: "ProfileViewController") as! ProfileViewController
        profileVC.user = user
        return profileVC
    }
}

// 3. 场景复用
protocol StoryboardInstantiable {
    static var storyboardIdentifier: String { get }
    static var storyboardName: String { get }
}

extension StoryboardInstantiable where Self: UIViewController {
    static func instantiate() -> Self {
        let storyboard = UIStoryboard(name: storyboardName, bundle: nil)
        return storyboard.instantiateViewController(withIdentifier: storyboardIdentifier) as! Self
    }
}

// 使用示例
extension DetailViewController: StoryboardInstantiable {
    static let storyboardIdentifier = "DetailViewController"
    static let storyboardName = "Main"
}

// 简化实例化
let detailVC = DetailViewController.instantiate()
```

## 📐 Auto Layout 深入理解

### Auto Layout 基础概念

```swift
// Auto Layout 核心要素:
/*
约束 (Constraints):
├── 位置约束
│   ├── Leading/Trailing (前导/后导)
│   ├── Top/Bottom (顶部/底部)
│   └── CenterX/CenterY (中心点)
├── 尺寸约束
│   ├── Width/Height (宽度/高度)
│   ├── Aspect Ratio (宽高比)
│   └── Equal Widths/Heights (等宽/等高)
└── 关系约束
    ├── Greater Than or Equal (大于等于)
    ├── Less Than or Equal (小于等于)
    └── Equal (等于)
*/
```

### 约束的创建方法

#### 1. Interface Builder 中创建约束

```swift
// IB 中添加约束的方法:
/*
方法1: Ctrl + 拖拽
├── 选中视图
├── Ctrl + 拖拽到目标视图或父视图
└── 选择约束类型

方法2: 约束按钮
├── 选中视图
├── 点击底部约束按钮
├── Pin (固定约束)
├── Align (对齐约束)
└── Resolve Issues (解决问题)

方法3: 尺寸检查器
├── 选中视图
├── 打开 Size Inspector
└── 在 Constraints 部分手动配置
*/

// 常见约束配置示例:
/*
居中显示:
├── Center X to Superview
└── Center Y to Superview

填满父视图:
├── Leading = Superview.Leading + 0
├── Trailing = Superview.Trailing + 0
├── Top = Superview.Top + 0
└── Bottom = Superview.Bottom + 0

固定尺寸:
├── Width = 200
└── Height = 100

相对布局:
├── Top = Superview.Top + 20
├── Leading = Superview.Leading + 16
├── Trailing = Superview.Trailing - 16
└── Height = 44
*/
```

#### 2. 程序化创建约束

```swift
// 使用 NSLayoutConstraint 创建约束
class ProgrammaticLayoutViewController: UIViewController {
    
    private let titleLabel = UILabel()
    private let descriptionLabel = UILabel()
    private let actionButton = UIButton(type: .system)
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupViews()
        setupConstraints()
    }
    
    private func setupViews() {
        view.backgroundColor = .systemBackground
        
        // 配置 titleLabel
        titleLabel.text = "欢迎使用应用"
        titleLabel.font = .systemFont(ofSize: 24, weight: .bold)
        titleLabel.textAlignment = .center
        titleLabel.translatesAutoresizingMaskIntoConstraints = false
        
        // 配置 descriptionLabel
        descriptionLabel.text = "这是一个使用程序化约束创建的界面示例"
        descriptionLabel.font = .systemFont(ofSize: 16)
        descriptionLabel.textAlignment = .center
        descriptionLabel.numberOfLines = 0
        descriptionLabel.translatesAutoresizingMaskIntoConstraints = false
        
        // 配置 actionButton
        actionButton.setTitle("开始使用", for: .normal)
        actionButton.backgroundColor = .systemBlue
        actionButton.setTitleColor(.white, for: .normal)
        actionButton.layer.cornerRadius = 8
        actionButton.translatesAutoresizingMaskIntoConstraints = false
        
        // 添加到视图层次
        view.addSubview(titleLabel)
        view.addSubview(descriptionLabel)
        view.addSubview(actionButton)
    }
    
    private func setupConstraints() {
        NSLayoutConstraint.activate([
            // titleLabel 约束
            titleLabel.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 60),
            titleLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            titleLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            
            // descriptionLabel 约束
            descriptionLabel.topAnchor.constraint(equalTo: titleLabel.bottomAnchor, constant: 30),
            descriptionLabel.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 20),
            descriptionLabel.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -20),
            
            // actionButton 约束
            actionButton.topAnchor.constraint(equalTo: descriptionLabel.bottomAnchor, constant: 40),
            actionButton.centerXAnchor.constraint(equalTo: view.centerXAnchor),
            actionButton.widthAnchor.constraint(equalToConstant: 200),
            actionButton.heightAnchor.constraint(equalToConstant: 44)
        ])
    }
}

// 使用 Visual Format Language (VFL)
extension ProgrammaticLayoutViewController {
    
    private func setupConstraintsWithVFL() {
        let views = [
            "titleLabel": titleLabel,
            "descriptionLabel": descriptionLabel,
            "actionButton": actionButton
        ]
        
        let metrics = [
            "margin": 20,
            "spacing": 30,
            "buttonWidth": 200,
            "buttonHeight": 44
        ]
        
        // 水平约束
        view.addConstraints(NSLayoutConstraint.constraints(
            withVisualFormat: "H:|-margin-[titleLabel]-margin-|",
            options: [],
            metrics: metrics,
            views: views
        ))
        
        view.addConstraints(NSLayoutConstraint.constraints(
            withVisualFormat: "H:|-margin-[descriptionLabel]-margin-|",
            options: [],
            metrics: metrics,
            views: views
        ))
        
        // 垂直约束
        view.addConstraints(NSLayoutConstraint.constraints(
            withVisualFormat: "V:|-60-[titleLabel]-spacing-[descriptionLabel]-40-[actionButton(buttonHeight)]",
            options: [],
            metrics: metrics,
            views: views
        ))
        
        // 按钮居中
        actionButton.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true
        actionButton.widthAnchor.constraint(equalToConstant: 200).isActive = true
    }
}
```

### 优先级和压缩阻力

```swift
// 约束优先级管理
class ConstraintPriorityViewController: UIViewController {
    
    @IBOutlet weak var flexibleLabel: UILabel!
    @IBOutlet weak var fixedLabel: UILabel!
    @IBOutlet weak var containerView: UIView!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupConstraintPriorities()
    }
    
    private func setupConstraintPriorities() {
        // 设置内容压缩阻力优先级
        flexibleLabel.setContentCompressionResistancePriority(.defaultLow, for: .horizontal)
        fixedLabel.setContentCompressionResistancePriority(.defaultHigh, for: .horizontal)
        
        // 设置内容拥抱优先级
        flexibleLabel.setContentHuggingPriority(.defaultLow, for: .horizontal)
        fixedLabel.setContentHuggingPriority(.defaultHigh, for: .horizontal)
        
        // 程序化约束优先级
        let widthConstraint = flexibleLabel.widthAnchor.constraint(equalToConstant: 200)
        widthConstraint.priority = UILayoutPriority(999) // 高优先级但不是必须
        widthConstraint.isActive = true
        
        // 条件性约束
        setupConditionalConstraints()
    }
    
    private func setupConditionalConstraints() {
        // iPhone 和 iPad 不同的约束
        if UIDevice.current.userInterfaceIdiom == .pad {
            // iPad 约束
            containerView.widthAnchor.constraint(lessThanOrEqualToConstant: 600).isActive = true
            containerView.centerXAnchor.constraint(equalTo: view.centerXAnchor).isActive = true
        } else {
            // iPhone 约束
            containerView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16).isActive = true
            containerView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16).isActive = true
        }
    }
}
```

## 📱 Size Classes 响应式设计

### Size Classes 基础

```swift
// Size Classes 概念:
/*
水平 Size Class:
├── Compact (紧凑)   // iPhone 竖屏, iPhone Plus 横屏
└── Regular (常规)   // iPad 所有方向, iPhone Plus 竖屏

垂直 Size Class:
├── Compact (紧凑)   // iPhone 横屏
└── Regular (常规)   // iPhone 竖屏, iPad 所有方向

组合情况:
├── wC hR: iPhone 竖屏
├── wC hC: iPhone 横屏  
├── wR hC: iPhone Plus 横屏
└── wR hR: iPad 所有方向, iPhone Plus 竖屏
*/
```

### 使用 Size Classes 进行适配

```swift
// Size Classes 适配实现
class ResponsiveViewController: UIViewController {
    
    @IBOutlet weak var mainStackView: UIStackView!
    @IBOutlet weak var primaryLabel: UILabel!
    @IBOutlet weak var secondaryLabel: UILabel!
    
    // Size Classes 约束集合
    @IBOutlet var compactConstraints: [NSLayoutConstraint]!
    @IBOutlet var regularConstraints: [NSLayoutConstraint]!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        updateLayoutForCurrentSizeClass()
    }
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        
        // 检测 Size Class 变化
        if traitCollection.horizontalSizeClass != previousTraitCollection?.horizontalSizeClass ||
           traitCollection.verticalSizeClass != previousTraitCollection?.verticalSizeClass {
            updateLayoutForCurrentSizeClass()
        }
    }
    
    private func updateLayoutForCurrentSizeClass() {
        let isCompact = traitCollection.horizontalSizeClass == .compact
        
        if isCompact {
            // 紧凑布局 (iPhone 竖屏)
            NSLayoutConstraint.deactivate(regularConstraints)
            NSLayoutConstraint.activate(compactConstraints)
            
            mainStackView.axis = .vertical
            mainStackView.spacing = 16
            
            primaryLabel.font = .systemFont(ofSize: 18, weight: .semibold)
            secondaryLabel.font = .systemFont(ofSize: 14)
            
        } else {
            // 常规布局 (iPad 或 iPhone Plus)
            NSLayoutConstraint.deactivate(compactConstraints)
            NSLayoutConstraint.activate(regularConstraints)
            
            mainStackView.axis = .horizontal
            mainStackView.spacing = 24
            
            primaryLabel.font = .systemFont(ofSize: 24, weight: .semibold)
            secondaryLabel.font = .systemFont(ofSize: 16)
        }
        
        // 更新其他UI元素
        updateButtonLayout(isCompact: isCompact)
        updateImageLayout(isCompact: isCompact)
    }
    
    private func updateButtonLayout(isCompact: Bool) {
        // 根据 Size Class 调整按钮布局
    }
    
    private func updateImageLayout(isCompact: Bool) {
        // 根据 Size Class 调整图片布局
    }
}

// 使用 Trait Collection 进行高级适配
extension ResponsiveViewController {
    
    private func setupAdvancedResponsiveDesign() {
        // 检测设备类型
        switch UIDevice.current.userInterfaceIdiom {
        case .phone:
            setupPhoneLayout()
        case .pad:
            setupPadLayout()
        default:
            setupDefaultLayout()
        }
        
        // 检测屏幕尺寸
        let screenSize = UIScreen.main.bounds.size
        let isLargeScreen = min(screenSize.width, screenSize.height) > 414 // iPhone 6 Plus+
        
        if isLargeScreen {
            setupLargeScreenOptimizations()
        }
    }
    
    private func setupPhoneLayout() {
        // iPhone 专用布局
    }
    
    private func setupPadLayout() {
        // iPad 专用布局
    }
    
    private func setupDefaultLayout() {
        // 默认布局
    }
    
    private func setupLargeScreenOptimizations() {
        // 大屏幕优化
    }
}
```

## 📚 Stack View 高效布局

### Stack View 基础使用

```swift
// Stack View 优势和使用场景
class StackViewViewController: UIViewController {
    
    private let mainStackView = UIStackView()
    private let headerStackView = UIStackView()
    private let contentStackView = UIStackView()
    private let footerStackView = UIStackView()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupStackViews()
        populateContent()
    }
    
    private func setupStackViews() {
        view.backgroundColor = .systemBackground
        
        // 主垂直 Stack View
        mainStackView.axis = .vertical
        mainStackView.distribution = .fill
        mainStackView.alignment = .fill
        mainStackView.spacing = 20
        mainStackView.translatesAutoresizingMaskIntoConstraints = false
        
        // 头部水平 Stack View
        headerStackView.axis = .horizontal
        headerStackView.distribution = .fillEqually
        headerStackView.alignment = .center
        headerStackView.spacing = 16
        
        // 内容垂直 Stack View
        contentStackView.axis = .vertical
        contentStackView.distribution = .fill
        contentStackView.alignment = .fill
        contentStackView.spacing = 12
        
        // 底部水平 Stack View
        footerStackView.axis = .horizontal
        footerStackView.distribution = .fillProportionally
        footerStackView.alignment = .center
        footerStackView.spacing = 12
        
        // 添加到视图层次
        view.addSubview(mainStackView)
        mainStackView.addArrangedSubview(headerStackView)
        mainStackView.addArrangedSubview(contentStackView)
        mainStackView.addArrangedSubview(footerStackView)
        
        // 设置约束
        NSLayoutConstraint.activate([
            mainStackView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor, constant: 20),
            mainStackView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: 16),
            mainStackView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -16),
            mainStackView.bottomAnchor.constraint(lessThanOrEqualTo: view.safeAreaLayoutGuide.bottomAnchor, constant: -20)
        ])
    }
    
    private func populateContent() {
        // 添加头部内容
        let titleLabel = createLabel(text: "标题", font: .systemFont(ofSize: 24, weight: .bold))
        let subtitleLabel = createLabel(text: "副标题", font: .systemFont(ofSize: 16, weight: .medium))
        
        headerStackView.addArrangedSubview(titleLabel)
        headerStackView.addArrangedSubview(subtitleLabel)
        
        // 添加内容
        for i in 1...5 {
            let contentLabel = createLabel(
                text: "内容项目 \(i)",
                font: .systemFont(ofSize: 14)
            )
            contentStackView.addArrangedSubview(contentLabel)
        }
        
        // 添加底部按钮
        let primaryButton = createButton(title: "主要操作", style: .filled)
        let secondaryButton = createButton(title: "次要操作", style: .bordered)
        
        footerStackView.addArrangedSubview(primaryButton)
        footerStackView.addArrangedSubview(secondaryButton)
    }
    
    // MARK: - Helper Methods
    
    private func createLabel(text: String, font: UIFont) -> UILabel {
        let label = UILabel()
        label.text = text
        label.font = font
        label.textAlignment = .center
        label.numberOfLines = 0
        return label
    }
    
    private func createButton(title: String, style: ButtonStyle) -> UIButton {
        let button = UIButton(type: .system)
        button.setTitle(title, for: .normal)
        button.titleLabel?.font = .systemFont(ofSize: 16, weight: .medium)
        
        switch style {
        case .filled:
            button.backgroundColor = .systemBlue
            button.setTitleColor(.white, for: .normal)
        case .bordered:
            button.backgroundColor = .clear
            button.setTitleColor(.systemBlue, for: .normal)
            button.layer.borderWidth = 1
            button.layer.borderColor = UIColor.systemBlue.cgColor
        }
        
        button.layer.cornerRadius = 8
        button.heightAnchor.constraint(equalToConstant: 44).isActive = true
        
        return button
    }
    
    enum ButtonStyle {
        case filled
        case bordered
    }
}

// 动态 Stack View 管理
extension StackViewViewController {
    
    private func addDynamicContent() {
        let newLabel = createLabel(text: "动态添加的内容", font: .systemFont(ofSize: 14))
        
        // 添加动画
        newLabel.alpha = 0
        contentStackView.addArrangedSubview(newLabel)
        
        UIView.animate(withDuration: 0.3) {
            newLabel.alpha = 1
            self.view.layoutIfNeeded()
        }
    }
    
    private func removeDynamicContent() {
        guard let lastView = contentStackView.arrangedSubviews.last else { return }
        
        UIView.animate(withDuration: 0.3, animations: {
            lastView.alpha = 0
            lastView.isHidden = true
        }) { _ in
            self.contentStackView.removeArrangedSubview(lastView)
            lastView.removeFromSuperview()
        }
    }
}
```

## 🌓 动态字体和无障碍设计

### 动态字体支持

```swift
// 动态字体适配
class AccessibilityViewController: UIViewController {
    
    @IBOutlet weak var headlineLabel: UILabel!
    @IBOutlet weak var bodyLabel: UILabel!
    @IBOutlet weak var captionLabel: UILabel!
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupDynamicType()
        registerForNotifications()
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    private func setupDynamicType() {
        // 设置动态字体
        headlineLabel.font = UIFont.preferredFont(forTextStyle: .headline)
        headlineLabel.adjustsFontForContentSizeCategory = true
        
        bodyLabel.font = UIFont.preferredFont(forTextStyle: .body)
        bodyLabel.adjustsFontForContentSizeCategory = true
        bodyLabel.numberOfLines = 0 // 支持多行显示
        
        captionLabel.font = UIFont.preferredFont(forTextStyle: .caption1)
        captionLabel.adjustsFontForContentSizeCategory = true
        
        // 设置最大和最小字体尺寸
        headlineLabel.maximumContentSizeCategory = .accessibilityExtraExtraExtraLarge
        headlineLabel.minimumContentSizeCategory = .small
    }
    
    private func registerForNotifications() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(contentSizeCategoryDidChange),
            name: UIContentSizeCategory.didChangeNotification,
            object: nil
        )
    }
    
    @objc private func contentSizeCategoryDidChange() {
        // 字体大小改变时的处理
        updateLayoutForNewFontSizes()
    }
    
    private func updateLayoutForNewFontSizes() {
        // 重新计算布局
        view.setNeedsLayout()
        view.layoutIfNeeded()
        
        // 如果是 Table View 或 Collection View，重新加载
        // tableView.reloadData()
    }
}

// 自定义字体的动态适配
extension AccessibilityViewController {
    
    private func setupCustomDynamicFont() {
        // 创建自定义字体的动态版本
        let customFont = UIFont(name: "YourCustomFont", size: 17) ?? UIFont.systemFont(ofSize: 17)
        let dynamicFont = UIFontMetrics(forTextStyle: .body).scaledFont(for: customFont)
        
        headlineLabel.font = dynamicFont
    }
}
```

### 无障碍支持

```swift
// 无障碍功能实现
extension AccessibilityViewController {
    
    private func setupAccessibility() {
        // 设置可访问性标签
        headlineLabel.accessibilityLabel = "主标题"
        headlineLabel.accessibilityTraits = .header
        
        bodyLabel.accessibilityLabel = "正文内容"
        bodyLabel.accessibilityHint = "这里显示详细的文章内容"
        
        // 设置可访问性元素组合
        let containerView = UIView()
        containerView.isAccessibilityElement = true
        containerView.accessibilityLabel = "文章摘要"
        containerView.accessibilityValue = "\(headlineLabel.text ?? ""), \(bodyLabel.text ?? "")"
        
        // 自定义可访问性操作
        let shareAction = UIAccessibilityCustomAction(
            name: "分享文章",
            target: self,
            selector: #selector(shareArticle)
        )
        
        let bookmarkAction = UIAccessibilityCustomAction(
            name: "添加书签",
            target: self,
            selector: #selector(bookmarkArticle)
        )
        
        containerView.accessibilityCustomActions = [shareAction, bookmarkAction]
    }
    
    @objc private func shareArticle() -> Bool {
        // 实现分享功能
        return true
    }
    
    @objc private func bookmarkArticle() -> Bool {
        // 实现书签功能
        return true
    }
    
    // 支持语音控制
    private func setupVoiceControlSupport() {
        headlineLabel.accessibilityUserInputLabels = ["标题", "主标题", "文章标题"]
        
        // 为按钮设置语音标识
        let actionButton = UIButton(type: .system)
        actionButton.accessibilityUserInputLabels = ["提交", "确认", "发送"]
    }
}
```

## 🎯 实践练习

### 练习1：响应式卡片布局

```swift
// 创建一个响应式的卡片布局
class ResponsiveCardViewController: UIViewController {
    
    private let scrollView = UIScrollView()
    private let stackView = UIStackView()
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupScrollView()
        createCards()
    }
    
    override func traitCollectionDidChange(_ previousTraitCollection: UITraitCollection?) {
        super.traitCollectionDidChange(previousTraitCollection)
        updateLayoutForTraitCollection()
    }
    
    private func setupScrollView() {
        view.backgroundColor = .systemGroupedBackground
        
        scrollView.translatesAutoresizingMaskIntoConstraints = false
        stackView.translatesAutoresizingMaskIntoConstraints = false
        
        stackView.axis = .vertical
        stackView.spacing = 16
        stackView.distribution = .fill
        
        scrollView.addSubview(stackView)
        view.addSubview(scrollView)
        
        NSLayoutConstraint.activate([
            scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            
            stackView.topAnchor.constraint(equalTo: scrollView.topAnchor, constant: 16),
            stackView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor, constant: 16),
            stackView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor, constant: -16),
            stackView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor, constant: -16),
            stackView.widthAnchor.constraint(equalTo: scrollView.widthAnchor, constant: -32)
        ])
    }
    
    private func createCards() {
        let cardData = [
            ("新闻", "今日头条新闻", "📰"),
            ("天气", "今天天气晴朗", "☀️"),
            ("日历", "今日有3个日程", "📅"),
            ("消息", "5条未读消息", "💬"),
            ("设置", "应用设置", "⚙️")
        ]
        
        for (title, subtitle, icon) in cardData {
            let card = createCardView(title: title, subtitle: subtitle, icon: icon)
            stackView.addArrangedSubview(card)
        }
    }
    
    private func createCardView(title: String, subtitle: String, icon: String) -> UIView {
        let cardView = UIView()
        cardView.backgroundColor = .systemBackground
        cardView.layer.cornerRadius = 12
        cardView.layer.shadowColor = UIColor.label.cgColor
        cardView.layer.shadowOpacity = 0.1
        cardView.layer.shadowOffset = CGSize(width: 0, height: 2)
        cardView.layer.shadowRadius = 4
        
        let iconLabel = UILabel()
        iconLabel.text = icon
        iconLabel.font = .systemFont(ofSize: 24)
        iconLabel.textAlignment = .center
        
        let titleLabel = UILabel()
        titleLabel.text = title
        titleLabel.font = UIFont.preferredFont(forTextStyle: .headline)
        titleLabel.adjustsFontForContentSizeCategory = true
        
        let subtitleLabel = UILabel()
        subtitleLabel.text = subtitle
        subtitleLabel.font = UIFont.preferredFont(forTextStyle: .subheadline)
        subtitleLabel.textColor = .secondaryLabel
        subtitleLabel.adjustsFontForContentSizeCategory = true
        subtitleLabel.numberOfLines = 0
        
        let contentStackView = UIStackView(arrangedSubviews: [titleLabel, subtitleLabel])
        contentStackView.axis = .vertical
        contentStackView.spacing = 4
        
        let mainStackView = UIStackView(arrangedSubviews: [iconLabel, contentStackView])
        mainStackView.axis = .horizontal
        mainStackView.spacing = 16
        mainStackView.alignment = .center
        mainStackView.translatesAutoresizingMaskIntoConstraints = false
        
        cardView.addSubview(mainStackView)
        
        NSLayoutConstraint.activate([
            mainStackView.topAnchor.constraint(equalTo: cardView.topAnchor, constant: 16),
            mainStackView.leadingAnchor.constraint(equalTo: cardView.leadingAnchor, constant: 16),
            mainStackView.trailingAnchor.constraint(equalTo: cardView.trailingAnchor, constant: -16),
            mainStackView.bottomAnchor.constraint(equalTo: cardView.bottomAnchor, constant: -16),
            
            cardView.heightAnchor.constraint(greaterThanOrEqualToConstant: 80),
            iconLabel.widthAnchor.constraint(equalToConstant: 40)
        ])
        
        return cardView
    }
    
    private func updateLayoutForTraitCollection() {
        let isCompact = traitCollection.horizontalSizeClass == .compact
        stackView.spacing = isCompact ? 12 : 16
        
        // 在 iPad 上使用不同的边距
        if !isCompact {
            let maxWidth: CGFloat = 600
            stackView.widthAnchor.constraint(lessThanOrEqualToConstant: maxWidth).isActive = true
        }
    }
}
```

### 练习2：自适应表单布局

```swift
// 创建一个自适应的表单界面
class AdaptiveFormViewController: UIViewController {
    
    private let scrollView = UIScrollView()
    private let formStackView = UIStackView()
    private var textFields: [UITextField] = []
    
    override func viewDidLoad() {
        super.viewDidLoad()
        setupForm()
        setupKeyboardHandling()
    }
    
    deinit {
        NotificationCenter.default.removeObserver(self)
    }
    
    private func setupForm() {
        view.backgroundColor = .systemGroupedBackground
        title = "用户注册"
        
        // 设置导航栏按钮
        navigationItem.rightBarButtonItem = UIBarButtonItem(
            title: "提交",
            style: .done,
            target: self,
            action: #selector(submitForm)
        )
        
        setupScrollView()
        createFormFields()
    }
    
    private func setupScrollView() {
        scrollView.translatesAutoresizingMaskIntoConstraints = false
        formStackView.translatesAutoresizingMaskIntoConstraints = false
        
        formStackView.axis = .vertical
        formStackView.spacing = 20
        formStackView.distribution = .fill
        
        scrollView.addSubview(formStackView)
        view.addSubview(scrollView)
        
        NSLayoutConstraint.activate([
            scrollView.topAnchor.constraint(equalTo: view.safeAreaLayoutGuide.topAnchor),
            scrollView.leadingAnchor.constraint(equalTo: view.leadingAnchor),
            scrollView.trailingAnchor.constraint(equalTo: view.trailingAnchor),
            scrollView.bottomAnchor.constraint(equalTo: view.bottomAnchor),
            
            formStackView.topAnchor.constraint(equalTo: scrollView.topAnchor, constant: 20),
            formStackView.leadingAnchor.constraint(equalTo: scrollView.leadingAnchor, constant: 20),
            formStackView.trailingAnchor.constraint(equalTo: scrollView.trailingAnchor, constant: -20),
            formStackView.bottomAnchor.constraint(equalTo: scrollView.bottomAnchor, constant: -20),
            formStackView.widthAnchor.constraint(equalTo: scrollView.widthAnchor, constant: -40)
        ])
    }
    
    private func createFormFields() {
        let fieldConfigs = [
            ("姓名", "请输入您的姓名", UIKeyboardType.default, UITextContentType.name),
            ("邮箱", "请输入邮箱地址", UIKeyboardType.emailAddress, UITextContentType.emailAddress),
            ("电话", "请输入手机号码", UIKeyboardType.phonePad, UITextContentType.telephoneNumber),
            ("密码", "请输入密码", UIKeyboardType.default, UITextContentType.newPassword),
            ("确认密码", "请再次输入密码", UIKeyboardType.default, UITextContentType.newPassword)
        ]
        
        for (label, placeholder, keyboardType, contentType) in fieldConfigs {
            let fieldContainer = createFormField(
                label: label,
                placeholder: placeholder,
                keyboardType: keyboardType,
                contentType: contentType
            )
            formStackView.addArrangedSubview(fieldContainer)
        }
        
        // 添加提交按钮
        let submitButton = createSubmitButton()
        formStackView.addArrangedSubview(submitButton)
    }
    
    private func createFormField(label: String, placeholder: String, 
                                keyboardType: UIKeyboardType, 
                                contentType: UITextContentType) -> UIView {
        let container = UIView()
        
        let labelView = UILabel()
        labelView.text = label
        labelView.font = UIFont.preferredFont(forTextStyle: .headline)
        labelView.adjustsFontForContentSizeCategory = true
        
        let textField = UITextField()
        textField.placeholder = placeholder
        textField.borderStyle = .roundedRect
        textField.keyboardType = keyboardType
        textField.textContentType = contentType
        textField.delegate = self
        
        // 密码字段特殊处理
        if contentType == .newPassword {
            textField.isSecureTextEntry = true
        }
        
        textFields.append(textField)
        
        let stackView = UIStackView(arrangedSubviews: [labelView, textField])
        stackView.axis = .vertical
        stackView.spacing = 8
        stackView.translatesAutoresizingMaskIntoConstraints = false
        
        container.addSubview(stackView)
        
        NSLayoutConstraint.activate([
            stackView.topAnchor.constraint(equalTo: container.topAnchor),
            stackView.leadingAnchor.constraint(equalTo: container.leadingAnchor),
            stackView.trailingAnchor.constraint(equalTo: container.trailingAnchor),
            stackView.bottomAnchor.constraint(equalTo: container.bottomAnchor),
            
            textField.heightAnchor.constraint(equalToConstant: 44)
        ])
        
        return container
    }
    
    private func createSubmitButton() -> UIButton {
        let button = UIButton(type: .system)
        button.setTitle("注册", for: .normal)
        button.backgroundColor = .systemBlue
        button.setTitleColor(.white, for: .normal)
        button.titleLabel?.font = UIFont.preferredFont(forTextStyle: .headline)
        button.layer.cornerRadius = 8
        button.addTarget(self, action: #selector(submitForm), for: .touchUpInside)
        
        button.heightAnchor.constraint(equalToConstant: 50).isActive = true
        
        return button
    }
    
    @objc private func submitForm() {
        // 验证表单
        guard validateForm() else { return }
        
        // 提交表单数据
        let formData = textFields.compactMap { $0.text }
        print("提交表单数据: \(formData)")
        
        // 显示成功消息
        showAlert(title: "成功", message: "注册成功！")
    }
    
    private func validateForm() -> Bool {
        for (index, textField) in textFields.enumerated() {
            if textField.text?.isEmpty ?? true {
                showAlert(title: "错误", message: "请填写所有必填字段")
                textField.becomeFirstResponder()
                return false
            }
            
            // 验证密码匹配
            if index == 4 { // 确认密码字段
                if textField.text != textFields[3].text {
                    showAlert(title: "错误", message: "两次输入的密码不匹配")
                    return false
                }
            }
        }
        return true
    }
    
    private func showAlert(title: String, message: String) {
        let alert = UIAlertController(title: title, message: message, preferredStyle: .alert)
        alert.addAction(UIAlertAction(title: "确定", style: .default))
        present(alert, animated: true)
    }
}

// MARK: - 键盘处理
extension AdaptiveFormViewController {
    
    private func setupKeyboardHandling() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(keyboardWillShow),
            name: UIResponder.keyboardWillShowNotification,
            object: nil
        )
        
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(keyboardWillHide),
            name: UIResponder.keyboardWillHideNotification,
            object: nil
        )
    }
    
    @objc private func keyboardWillShow(_ notification: Notification) {
        guard let keyboardFrame = notification.userInfo?[UIResponder.keyboardFrameEndUserInfoKey] as? CGRect else { return }
        
        let keyboardHeight = keyboardFrame.height
        scrollView.contentInset.bottom = keyboardHeight
        scrollView.scrollIndicatorInsets.bottom = keyboardHeight
    }
    
    @objc private func keyboardWillHide(_ notification: Notification) {
        scrollView.contentInset.bottom = 0
        scrollView.scrollIndicatorInsets.bottom = 0
    }
}

// MARK: - UITextFieldDelegate
extension AdaptiveFormViewController: UITextFieldDelegate {
    
    func textFieldShouldReturn(_ textField: UITextField) -> Bool {
        if let currentIndex = textFields.firstIndex(of: textField) {
            let nextIndex = currentIndex + 1
            if nextIndex < textFields.count {
                textFields[nextIndex].becomeFirstResponder()
            } else {
                textField.resignFirstResponder()
                submitForm()
            }
        }
        return true
    }
}
```

## 📝 小结

### 重点回顾

1. **Interface Builder**: 可视化界面设计工具的使用和最佳实践
2. **Storyboard**: 场景管理、Segue使用和模块化设计
3. **Auto Layout**: 约束系统、优先级和程序化布局
4. **Size Classes**: 响应式设计和多设备适配
5. **Stack View**: 高效的自适应布局解决方案
6. **动态字体**: 无障碍设计和用户友好性

### 最佳实践

- **模块化Storyboard**: 避免单个Storyboard过大
- **优先使用Stack View**: 减少约束复杂性
- **支持动态字体**: 提高可访问性
- **响应式设计**: 适配不同设备和方向
- **约束优先级**: 合理设置以避免冲突
- **性能优化**: 避免过度复杂的约束关系

### 常见陷阱

- 约束冲突导致的布局问题
- 忘记设置translatesAutoresizingMaskIntoConstraints
- 过度依赖固定尺寸而忽视动态适配
- Storyboard过于复杂难以维护
- 忽视无障碍设计要求

## 🔄 下一步

掌握界面设计基础后，接下来学习：

- **[视图与视图控制器](./04-视图与视图控制器.md)**: 深入理解视图系统和MVC模式
- **[用户界面组件](./05-用户界面组件.md)**: 学习各种UI控件的使用

**你已经掌握了iOS界面设计的核心技能！** 🎨 