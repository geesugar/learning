# Swifté”™è¯¯å¤„ç†

## ğŸ“– æ¦‚è¿°

é”™è¯¯å¤„ç†æ˜¯ç¼–ç¨‹ä¸­å¤„ç†å¤±è´¥æ¡ä»¶çš„è¿‡ç¨‹ã€‚Swiftæä¾›äº†ä¸€å¥—å®Œæ•´çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œè®©å¼€å‘è€…èƒ½å¤Ÿä¼˜é›…åœ°å¤„ç†è¿è¡Œæ—¶å¯èƒ½å‡ºç°çš„é”™è¯¯æƒ…å†µã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

- ç†è§£Swifté”™è¯¯å¤„ç†çš„æ ¸å¿ƒæ¦‚å¿µ
- æŒæ¡é”™è¯¯ç±»å‹çš„å®šä¹‰å’Œä½¿ç”¨
- å­¦ä¼šä½¿ç”¨do-catchè¯­å¥å¤„ç†é”™è¯¯
- ç†è§£é”™è¯¯ä¼ æ’­æœºåˆ¶
- æŒæ¡deferè¯­å¥çš„ä½¿ç”¨
- å­¦ä¼šåœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨é”™è¯¯å¤„ç†

## âš ï¸ é”™è¯¯ç±»å‹å®šä¹‰

### Erroråè®®

```swift
// Swiftä¸­çš„é”™è¯¯å¿…é¡»éµå¾ªErroråè®®
enum FileError: Error {
    case fileNotFound
    case noPermission
    case unknownError
}

enum NetworkError: Error {
    case noConnection
    case timeout
    case invalidURL
    case serverError(code: Int)
}

enum ValidationError: Error {
    case emptyInput
    case invalidEmail
    case passwordTooShort
    case custom(message: String)
}
```

### å¸¦å…³è”å€¼çš„é”™è¯¯

```swift
enum DatabaseError: Error {
    case connectionFailed(reason: String)
    case queryFailed(query: String, error: String)
    case dataCorrupted(table: String)
    case insufficientSpace(required: Int, available: Int)
}

// ä½¿ç”¨ç¤ºä¾‹
let dbError = DatabaseError.insufficientSpace(required: 1000, available: 500)

// å¯ä»¥å®ç°LocalizedErroråè®®æä¾›æœ¬åœ°åŒ–é”™è¯¯æè¿°
extension DatabaseError: LocalizedError {
    var errorDescription: String? {
        switch self {
        case .connectionFailed(let reason):
            return "æ•°æ®åº“è¿æ¥å¤±è´¥: \(reason)"
        case .queryFailed(let query, let error):
            return "æŸ¥è¯¢æ‰§è¡Œå¤±è´¥: \(query) - \(error)"
        case .dataCorrupted(let table):
            return "æ•°æ®è¡¨æŸå: \(table)"
        case .insufficientSpace(let required, let available):
            return "å­˜å‚¨ç©ºé—´ä¸è¶³: éœ€è¦\(required)MBï¼Œå¯ç”¨\(available)MB"
        }
    }
}
```

### è‡ªå®šä¹‰é”™è¯¯ç»“æ„ä½“

```swift
struct APIError: Error {
    let code: Int
    let message: String
    let timestamp: Date
    
    init(code: Int, message: String) {
        self.code = code
        self.message = message
        self.timestamp = Date()
    }
}

extension APIError: LocalizedError {
    var errorDescription: String? {
        return "APIé”™è¯¯ [\(code)]: \(message)"
    }
}

// ä½¿ç”¨
let apiError = APIError(code: 404, message: "èµ„æºæœªæ‰¾åˆ°")
print(apiError.localizedDescription)
```

## ğŸ² æŠ›å‡ºé”™è¯¯

### ä½¿ç”¨throwså…³é”®å­—

```swift
// å£°æ˜å¯èƒ½æŠ›å‡ºé”™è¯¯çš„å‡½æ•°
func divide(_ a: Double, by b: Double) throws -> Double {
    guard b != 0 else {
        throw MathError.divisionByZero
    }
    return a / b
}

enum MathError: Error {
    case divisionByZero
    case negativeSquareRoot
    case overflow
}

// æŠ›å‡ºå¤šç§ç±»å‹çš„é”™è¯¯
func validateInput(_ input: String) throws -> Int {
    guard !input.isEmpty else {
        throw ValidationError.emptyInput
    }
    
    guard let number = Int(input) else {
        throw ValidationError.custom(message: "è¾“å…¥å¿…é¡»æ˜¯æ•°å­—")
    }
    
    guard number >= 0 else {
        throw ValidationError.custom(message: "æ•°å­—å¿…é¡»ä¸ºæ­£æ•°")
    }
    
    return number
}

// å®é™…åº”ç”¨ï¼šæ–‡ä»¶æ“ä½œ
func readFileContent(filename: String) throws -> String {
    guard !filename.isEmpty else {
        throw FileError.fileNotFound
    }
    
    // æ¨¡æ‹Ÿæ–‡ä»¶è¯»å–
    if filename == "secret.txt" {
        throw FileError.noPermission
    }
    
    if filename == "corrupted.txt" {
        throw FileError.unknownError
    }
    
    return "æ–‡ä»¶å†…å®¹: \(filename)"
}
```

### æ¡ä»¶æŠ›å‡º

```swift
func processUser(age: Int?, name: String?) throws -> String {
    guard let name = name, !name.isEmpty else {
        throw ValidationError.emptyInput
    }
    
    guard let age = age, age > 0 else {
        throw ValidationError.custom(message: "å¹´é¾„å¿…é¡»æ˜¯æ­£æ•°")
    }
    
    guard age < 150 else {
        throw ValidationError.custom(message: "å¹´é¾„ä¸èƒ½è¶…è¿‡150å²")
    }
    
    return "ç”¨æˆ·: \(name), å¹´é¾„: \(age)"
}
```

## ğŸ¯ æ•è·å’Œå¤„ç†é”™è¯¯

### do-catchè¯­å¥

```swift
// åŸºæœ¬do-catchè¯­æ³•
do {
    let result = try divide(10, by: 2)
    print("é™¤æ³•ç»“æœ: \(result)")
} catch MathError.divisionByZero {
    print("é”™è¯¯: ä¸èƒ½é™¤ä»¥é›¶")
} catch {
    print("å…¶ä»–é”™è¯¯: \(error)")
}

// æ•è·å¤šç§é”™è¯¯ç±»å‹
do {
    let userInfo = try processUser(age: 25, name: "Alice")
    print(userInfo)
} catch ValidationError.emptyInput {
    print("è¾“å…¥ä¸èƒ½ä¸ºç©º")
} catch ValidationError.custom(let message) {
    print("éªŒè¯é”™è¯¯: \(message)")
} catch {
    print("æœªçŸ¥é”™è¯¯: \(error)")
}

// æ•è·å¸¦å…³è”å€¼çš„é”™è¯¯
do {
    // æ¨¡æ‹Ÿæ•°æ®åº“æ“ä½œ
    throw DatabaseError.connectionFailed(reason: "ç½‘ç»œè¶…æ—¶")
} catch DatabaseError.connectionFailed(let reason) {
    print("æ•°æ®åº“è¿æ¥å¤±è´¥: \(reason)")
} catch DatabaseError.queryFailed(let query, let error) {
    print("æŸ¥è¯¢å¤±è´¥: \(query) - \(error)")
} catch DatabaseError.insufficientSpace(let required, let available) {
    print("å­˜å‚¨ç©ºé—´ä¸è¶³: éœ€è¦\(required)MBï¼Œå¯ç”¨\(available)MB")
} catch {
    print("å…¶ä»–æ•°æ®åº“é”™è¯¯: \(error)")
}
```

### é”™è¯¯ç±»å‹åŒ¹é…

```swift
func handleError(_ error: Error) {
    switch error {
    case FileError.fileNotFound:
        print("æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„")
    case FileError.noPermission:
        print("æ²¡æœ‰è®¿é—®æƒé™ï¼Œè¯·è”ç³»ç®¡ç†å‘˜")
    case NetworkError.timeout:
        print("ç½‘ç»œè¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
    case NetworkError.serverError(let code):
        print("æœåŠ¡å™¨é”™è¯¯ï¼ŒçŠ¶æ€ç : \(code)")
    case let validationError as ValidationError:
        print("éªŒè¯é”™è¯¯: \(validationError.localizedDescription)")
    default:
        print("æœªçŸ¥é”™è¯¯: \(error)")
    }
}

// æµ‹è¯•é”™è¯¯å¤„ç†
let errors: [Error] = [
    FileError.fileNotFound,
    NetworkError.serverError(code: 500),
    ValidationError.emptyInput
]

for error in errors {
    handleError(error)
}
```

## ğŸ”„ é”™è¯¯ä¼ æ’­

### å‘ä¸Šä¼ æ’­é”™è¯¯

```swift
// é”™è¯¯ä¼šè‡ªåŠ¨å‘ä¸Šä¼ æ’­
func level1() throws {
    try level2()
}

func level2() throws {
    try level3()
}

func level3() throws {
    throw NetworkError.timeout
}

// è°ƒç”¨ä¼ æ’­é“¾
do {
    try level1()
} catch NetworkError.timeout {
    print("åœ¨é¡¶å±‚æ•è·äº†ç½‘ç»œè¶…æ—¶é”™è¯¯")
} catch {
    print("æ•è·äº†å…¶ä»–é”™è¯¯: \(error)")
}

// å®é™…åº”ç”¨ï¼šç”¨æˆ·æ³¨å†Œæµç¨‹
func registerUser(email: String, password: String) throws -> Bool {
    try validateEmail(email)
    try validatePassword(password)
    try saveToDatabase(email: email, password: password)
    try sendConfirmationEmail(to: email)
    return true
}

func validateEmail(_ email: String) throws {
    guard email.contains("@") && email.contains(".") else {
        throw ValidationError.invalidEmail
    }
}

func validatePassword(_ password: String) throws {
    guard password.count >= 8 else {
        throw ValidationError.passwordTooShort
    }
}

func saveToDatabase(email: String, password: String) throws {
    // æ¨¡æ‹Ÿæ•°æ®åº“ä¿å­˜
    if email == "admin@test.com" {
        throw DatabaseError.connectionFailed(reason: "æ•°æ®åº“ç»´æŠ¤ä¸­")
    }
}

func sendConfirmationEmail(to email: String) throws {
    // æ¨¡æ‹Ÿå‘é€é‚®ä»¶
    if email.hasSuffix("@invalid.com") {
        throw NetworkError.invalidURL
    }
}

// ä½¿ç”¨æ³¨å†Œæµç¨‹
do {
    let success = try registerUser(email: "user@example.com", password: "password123")
    print("ç”¨æˆ·æ³¨å†ŒæˆåŠŸ: \(success)")
} catch ValidationError.invalidEmail {
    print("é‚®ç®±æ ¼å¼é”™è¯¯")
} catch ValidationError.passwordTooShort {
    print("å¯†ç é•¿åº¦è‡³å°‘8ä½")
} catch DatabaseError.connectionFailed(let reason) {
    print("æ•°æ®åº“é”™è¯¯: \(reason)")
} catch NetworkError.invalidURL {
    print("é‚®ä»¶å‘é€å¤±è´¥")
} catch {
    print("æ³¨å†Œå¤±è´¥: \(error)")
}
```

## ğŸ”§ ä¸åŒçš„tryä½¿ç”¨æ–¹å¼

### try - å¿…é¡»å¤„ç†é”™è¯¯

```swift
// æ ‡å‡†tryï¼Œå¿…é¡»åœ¨do-catchä¸­ä½¿ç”¨
do {
    let result = try divide(10, by: 0)
    print("ç»“æœ: \(result)")
} catch {
    print("å‘ç”Ÿé”™è¯¯: \(error)")
}
```

### try? - è½¬æ¢ä¸ºå¯é€‰ç±»å‹

```swift
// try? å°†é”™è¯¯è½¬æ¢ä¸ºnil
let result1 = try? divide(10, by: 2)  // Optional(5.0)
let result2 = try? divide(10, by: 0)  // nil

print("ç»“æœ1: \(result1 ?? 0)")  // ç»“æœ1: 5.0
print("ç»“æœ2: \(result2 ?? 0)")  // ç»“æœ2: 0

// å®é™…åº”ç”¨ï¼šå¯é€‰é“¾å¼è°ƒç”¨
func processOptionalResult() {
    if let content = try? readFileContent(filename: "config.txt") {
        print("æ–‡ä»¶å†…å®¹: \(content)")
    } else {
        print("æ— æ³•è¯»å–æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤é…ç½®")
    }
}

// é“¾å¼å¤„ç†å¤šä¸ªå¯èƒ½å¤±è´¥çš„æ“ä½œ
let userAge = try? validateInput("25")
let userName = try? processUser(age: userAge, name: "Bob")
print("å¤„ç†ç»“æœ: \(userName ?? "å¤„ç†å¤±è´¥")")
```

### try! - å¼ºåˆ¶è§£åŒ…ï¼ˆå±é™©ï¼‰

```swift
// try! å‡è®¾æ“ä½œä¸ä¼šå¤±è´¥ï¼Œå¦‚æœå¤±è´¥ç¨‹åºä¼šå´©æºƒ
let safeResult = try! divide(10, by: 2)  // 5.0ï¼Œå®‰å…¨
// let unsafeResult = try! divide(10, by: 0)  // ä¼šå¯¼è‡´ç¨‹åºå´©æºƒ

// ä»…åœ¨ç¡®å®šä¸ä¼šå¤±è´¥æ—¶ä½¿ç”¨
func loadCriticalResource() {
    // è¿™äº›èµ„æºå¿…é¡»å­˜åœ¨ï¼Œå¦åˆ™ç¨‹åºæ— æ³•è¿è¡Œ
    let config = try! readFileContent(filename: "app.config")
    print("å…³é”®é…ç½®: \(config)")
}

// æ›´å®‰å…¨çš„æ›¿ä»£æ–¹æ¡ˆ
func loadCriticalResourceSafely() {
    do {
        let config = try readFileContent(filename: "app.config")
        print("å…³é”®é…ç½®: \(config)")
    } catch {
        fatalError("æ— æ³•åŠ è½½å…³é”®é…ç½®æ–‡ä»¶: \(error)")
    }
}
```

## ğŸ§¹ deferè¯­å¥

### deferåŸºç¡€ç”¨æ³•

```swift
func processFile() {
    print("1. å¼€å§‹å¤„ç†æ–‡ä»¶")
    
    defer {
        print("4. æ¸…ç†èµ„æºï¼ˆdeferè¯­å¥ï¼‰")
    }
    
    print("2. æ­£åœ¨å¤„ç†æ–‡ä»¶")
    
    defer {
        print("3. å…³é—­æ–‡ä»¶ï¼ˆç¬¬äºŒä¸ªdeferï¼‰")
    }
    
    print("å¤„ç†å®Œæˆ")
    // deferæŒ‰ç…§å®šä¹‰çš„ç›¸åé¡ºåºæ‰§è¡Œ
}

processFile()
// è¾“å‡ºï¼š
// 1. å¼€å§‹å¤„ç†æ–‡ä»¶
// 2. æ­£åœ¨å¤„ç†æ–‡ä»¶
// å¤„ç†å®Œæˆ
// 3. å…³é—­æ–‡ä»¶ï¼ˆç¬¬äºŒä¸ªdeferï¼‰
// 4. æ¸…ç†èµ„æºï¼ˆdeferè¯­å¥ï¼‰
```

### deferåœ¨é”™è¯¯å¤„ç†ä¸­çš„åº”ç”¨

```swift
func processDataFile(filename: String) throws {
    print("æ‰“å¼€æ–‡ä»¶: \(filename)")
    
    // æ— è®ºå‡½æ•°å¦‚ä½•é€€å‡ºï¼Œéƒ½ä¼šæ‰§è¡Œæ¸…ç†
    defer {
        print("å…³é—­æ–‡ä»¶: \(filename)")
    }
    
    guard filename != "corrupted.txt" else {
        throw FileError.unknownError
    }
    
    guard filename != "secret.txt" else {
        throw FileError.noPermission
    }
    
    print("æˆåŠŸå¤„ç†æ–‡ä»¶: \(filename)")
}

// æµ‹è¯•ä¸åŒæƒ…å†µ
let testFiles = ["normal.txt", "secret.txt", "corrupted.txt"]

for file in testFiles {
    print("\n--- å¤„ç† \(file) ---")
    do {
        try processDataFile(filename: file)
    } catch {
        print("é”™è¯¯: \(error)")
    }
}
```

### deferåœ¨èµ„æºç®¡ç†ä¸­çš„åº”ç”¨

```swift
class DatabaseConnection {
    let name: String
    
    init(name: String) {
        self.name = name
        print("ğŸ“¡ æ‰“å¼€æ•°æ®åº“è¿æ¥: \(name)")
    }
    
    func execute(_ query: String) throws {
        if query.contains("DROP") {
            throw DatabaseError.queryFailed(query: query, error: "å±é™©æ“ä½œè¢«ç¦æ­¢")
        }
        print("ğŸ” æ‰§è¡ŒæŸ¥è¯¢: \(query)")
    }
    
    func close() {
        print("ğŸ”’ å…³é—­æ•°æ®åº“è¿æ¥: \(name)")
    }
}

func performDatabaseOperations() throws {
    let db = DatabaseConnection(name: "MainDB")
    
    // ç¡®ä¿è¿æ¥ä¼šè¢«å…³é—­
    defer {
        db.close()
    }
    
    try db.execute("SELECT * FROM users")
    try db.execute("UPDATE users SET active = true")
    
    // è¿™è¡Œä¼šæŠ›å‡ºé”™è¯¯
    try db.execute("DROP TABLE users")
}

// æµ‹è¯•
do {
    try performDatabaseOperations()
} catch {
    print("âŒ æ•°æ®åº“æ“ä½œå¤±è´¥: \(error)")
}
```

## ğŸ¯ å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šæ–‡ä»¶ç®¡ç†ç³»ç»Ÿ

```swift
enum FileSystemError: Error {
    case fileNotFound(path: String)
    case insufficientPermissions
    case diskFull
    case invalidPath
    case fileAlreadyExists
}

class FileManager {
    private var openFiles: Set<String> = []
    
    func createFile(at path: String, content: String) throws {
        guard !path.isEmpty else {
            throw FileSystemError.invalidPath
        }
        
        guard !openFiles.contains(path) else {
            throw FileSystemError.fileAlreadyExists
        }
        
        // æ¨¡æ‹Ÿç£ç›˜ç©ºé—´æ£€æŸ¥
        if content.count > 1000 {
            throw FileSystemError.diskFull
        }
        
        openFiles.insert(path)
        print("âœ… åˆ›å»ºæ–‡ä»¶: \(path)")
        
        defer {
            print("ğŸ”’ æ–‡ä»¶åˆ›å»ºæ“ä½œå®Œæˆ")
        }
    }
    
    func readFile(at path: String) throws -> String {
        guard !path.isEmpty else {
            throw FileSystemError.invalidPath
        }
        
        guard openFiles.contains(path) else {
            throw FileSystemError.fileNotFound(path: path)
        }
        
        // æ¨¡æ‹Ÿæƒé™æ£€æŸ¥
        if path.contains("private") {
            throw FileSystemError.insufficientPermissions
        }
        
        defer {
            print("ğŸ“– æ–‡ä»¶è¯»å–æ“ä½œå®Œæˆ")
        }
        
        return "æ–‡ä»¶å†…å®¹: \(path)"
    }
    
    func deleteFile(at path: String) throws {
        defer {
            print("ğŸ—‘ï¸ åˆ é™¤æ“ä½œå®Œæˆ")
        }
        
        guard openFiles.contains(path) else {
            throw FileSystemError.fileNotFound(path: path)
        }
        
        openFiles.remove(path)
        print("âŒ åˆ é™¤æ–‡ä»¶: \(path)")
    }
    
    func copyFile(from source: String, to destination: String) throws {
        let content = try readFile(at: source)
        try createFile(at: destination, content: content)
        print("ğŸ“‹ å¤åˆ¶æ–‡ä»¶: \(source) -> \(destination)")
    }
}

// æµ‹è¯•æ–‡ä»¶ç®¡ç†ç³»ç»Ÿ
let fileManager = FileManager()

do {
    // åˆ›å»ºæ–‡ä»¶
    try fileManager.createFile(at: "document.txt", content: "Hello World")
    try fileManager.createFile(at: "data.txt", content: "Some data")
    
    // è¯»å–æ–‡ä»¶
    let content = try fileManager.readFile(at: "document.txt")
    print("è¯»å–å†…å®¹: \(content)")
    
    // å¤åˆ¶æ–‡ä»¶
    try fileManager.copyFile(from: "document.txt", to: "backup.txt")
    
    // å°è¯•è®¿é—®ç§æœ‰æ–‡ä»¶ï¼ˆä¼šå¤±è´¥ï¼‰
    try fileManager.createFile(at: "private_secret.txt", content: "Secret")
    try fileManager.readFile(at: "private_secret.txt")
    
} catch FileSystemError.fileNotFound(let path) {
    print("âŒ æ–‡ä»¶æœªæ‰¾åˆ°: \(path)")
} catch FileSystemError.insufficientPermissions {
    print("âŒ æƒé™ä¸è¶³")
} catch FileSystemError.diskFull {
    print("âŒ ç£ç›˜ç©ºé—´ä¸è¶³")
} catch FileSystemError.invalidPath {
    print("âŒ æ— æ•ˆè·¯å¾„")
} catch FileSystemError.fileAlreadyExists {
    print("âŒ æ–‡ä»¶å·²å­˜åœ¨")
} catch {
    print("âŒ æœªçŸ¥é”™è¯¯: \(error)")
}
```

### ç»ƒä¹ 2ï¼šç½‘ç»œè¯·æ±‚ç®¡ç†å™¨

```swift
enum HTTPError: Error {
    case invalidURL
    case noConnection
    case timeout
    case unauthorized
    case serverError(code: Int)
    case invalidResponse
    case decodingError
}

struct APIResponse {
    let data: String
    let statusCode: Int
}

class NetworkManager {
    private var activeConnections: Int = 0
    private let maxConnections = 3
    
    func makeRequest(to url: String) throws -> APIResponse {
        guard !url.isEmpty else {
            throw HTTPError.invalidURL
        }
        
        guard activeConnections < maxConnections else {
            throw HTTPError.timeout
        }
        
        activeConnections += 1
        
        defer {
            activeConnections -= 1
            print("ğŸ”— è¿æ¥æ•°: \(activeConnections)")
        }
        
        print("ğŸŒ å‘èµ·è¯·æ±‚: \(url)")
        
        // æ¨¡æ‹Ÿå„ç§å“åº”æƒ…å†µ
        switch url {
        case let u where u.contains("invalid"):
            throw HTTPError.invalidURL
        case let u where u.contains("unauthorized"):
            throw HTTPError.unauthorized
        case let u where u.contains("500"):
            throw HTTPError.serverError(code: 500)
        case let u where u.contains("timeout"):
            throw HTTPError.timeout
        default:
            return APIResponse(data: "å“åº”æ•°æ®: \(url)", statusCode: 200)
        }
    }
    
    func fetchUserData(userId: String) throws -> String {
        let url = "https://api.example.com/users/\(userId)"
        let response = try makeRequest(to: url)
        
        guard response.statusCode == 200 else {
            throw HTTPError.serverError(code: response.statusCode)
        }
        
        return response.data
    }
    
    func batchRequest(urls: [String]) -> [(url: String, result: Result<APIResponse, Error>)] {
        var results: [(String, Result<APIResponse, Error>)] = []
        
        for url in urls {
            let result: Result<APIResponse, Error>
            do {
                let response = try makeRequest(to: url)
                result = .success(response)
            } catch {
                result = .failure(error)
            }
            results.append((url, result))
        }
        
        return results
    }
}

// æµ‹è¯•ç½‘ç»œè¯·æ±‚ç®¡ç†å™¨
let networkManager = NetworkManager()

// å•ä¸ªè¯·æ±‚æµ‹è¯•
let testUrls = [
    "https://api.example.com/data",
    "https://api.example.com/invalid",
    "https://api.example.com/unauthorized",
    "https://api.example.com/500"
]

print("=== å•ä¸ªè¯·æ±‚æµ‹è¯• ===")
for url in testUrls {
    do {
        let response = try networkManager.makeRequest(to: url)
        print("âœ… æˆåŠŸ: \(url) - \(response.data)")
    } catch HTTPError.invalidURL {
        print("âŒ æ— æ•ˆURL: \(url)")
    } catch HTTPError.unauthorized {
        print("âŒ æœªæˆæƒ: \(url)")
    } catch HTTPError.serverError(let code) {
        print("âŒ æœåŠ¡å™¨é”™è¯¯ \(code): \(url)")
    } catch {
        print("âŒ å…¶ä»–é”™è¯¯: \(url) - \(error)")
    }
}

// æ‰¹é‡è¯·æ±‚æµ‹è¯•
print("\n=== æ‰¹é‡è¯·æ±‚æµ‹è¯• ===")
let batchUrls = [
    "https://api.example.com/users/1",
    "https://api.example.com/users/2",
    "https://api.example.com/timeout",
    "https://api.example.com/users/3"
]

let batchResults = networkManager.batchRequest(urls: batchUrls)
for (url, result) in batchResults {
    switch result {
    case .success(let response):
        print("âœ… \(url): \(response.data)")
    case .failure(let error):
        print("âŒ \(url): \(error)")
    }
}
```

### ç»ƒä¹ 3ï¼šæ•°æ®éªŒè¯å’Œè½¬æ¢ç³»ç»Ÿ

```swift
enum DataValidationError: Error {
    case invalidFormat
    case outOfRange(min: Int, max: Int, actual: Int)
    case missingRequiredField(field: String)
    case typeMismatch(expected: String, actual: String)
    case customValidation(message: String)
}

struct UserProfile {
    let name: String
    let age: Int
    let email: String
    let phone: String?
}

class DataValidator {
    
    // éªŒè¯å§“å
    func validateName(_ name: String?) throws -> String {
        guard let name = name, !name.isEmpty else {
            throw DataValidationError.missingRequiredField(field: "name")
        }
        
        guard name.count >= 2 && name.count <= 50 else {
            throw DataValidationError.outOfRange(min: 2, max: 50, actual: name.count)
        }
        
        return name.trimmingCharacters(in: .whitespacesAndNewlines)
    }
    
    // éªŒè¯å¹´é¾„
    func validateAge(_ ageString: String?) throws -> Int {
        guard let ageString = ageString, !ageString.isEmpty else {
            throw DataValidationError.missingRequiredField(field: "age")
        }
        
        guard let age = Int(ageString) else {
            throw DataValidationError.typeMismatch(expected: "Int", actual: "String")
        }
        
        guard age >= 0 && age <= 150 else {
            throw DataValidationError.outOfRange(min: 0, max: 150, actual: age)
        }
        
        return age
    }
    
    // éªŒè¯é‚®ç®±
    func validateEmail(_ email: String?) throws -> String {
        guard let email = email, !email.isEmpty else {
            throw DataValidationError.missingRequiredField(field: "email")
        }
        
        let emailRegex = #"^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$"#
        let emailPredicate = NSPredicate(format: "SELF MATCHES %@", emailRegex)
        
        guard emailPredicate.evaluate(with: email) else {
            throw DataValidationError.invalidFormat
        }
        
        return email.lowercased()
    }
    
    // éªŒè¯æ‰‹æœºå·ï¼ˆå¯é€‰ï¼‰
    func validatePhone(_ phone: String?) throws -> String? {
        guard let phone = phone, !phone.isEmpty else {
            return nil  // æ‰‹æœºå·æ˜¯å¯é€‰çš„
        }
        
        let cleanPhone = phone.replacingOccurrences(of: "[^0-9]", with: "", options: .regularExpression)
        
        guard cleanPhone.count >= 10 && cleanPhone.count <= 15 else {
            throw DataValidationError.customValidation(message: "æ‰‹æœºå·é•¿åº¦åº”åœ¨10-15ä½ä¹‹é—´")
        }
        
        return cleanPhone
    }
    
    // éªŒè¯å®Œæ•´ç”¨æˆ·æ¡£æ¡ˆ
    func validateUserProfile(data: [String: String?]) throws -> UserProfile {
        defer {
            print("ğŸ” ç”¨æˆ·æ¡£æ¡ˆéªŒè¯å®Œæˆ")
        }
        
        do {
            let name = try validateName(data["name"] ?? nil)
            let age = try validateAge(data["age"] ?? nil)
            let email = try validateEmail(data["email"] ?? nil)
            let phone = try validatePhone(data["phone"] ?? nil)
            
            return UserProfile(name: name, age: age, email: email, phone: phone)
        } catch {
            print("âŒ éªŒè¯å¤±è´¥: \(error)")
            throw error
        }
    }
}

// æµ‹è¯•æ•°æ®éªŒè¯ç³»ç»Ÿ
let validator = DataValidator()

// æµ‹è¯•ç”¨ä¾‹
let testCases: [[String: String?]] = [
    // æœ‰æ•ˆæ•°æ®
    [
        "name": "å¼ ä¸‰",
        "age": "25",
        "email": "zhangsan@example.com",
        "phone": "13800138000"
    ],
    // ç¼ºå°‘å¿…å¡«å­—æ®µ
    [
        "name": "æå››",
        "age": "30",
        "phone": "13900139000"
    ],
    // å¹´é¾„æ ¼å¼é”™è¯¯
    [
        "name": "ç‹äº”",
        "age": "abc",
        "email": "wangwu@example.com"
    ],
    // é‚®ç®±æ ¼å¼é”™è¯¯
    [
        "name": "èµµå…­",
        "age": "28",
        "email": "invalid-email"
    ],
    // å¹´é¾„è¶…å‡ºèŒƒå›´
    [
        "name": "å­™ä¸ƒ",
        "age": "200",
        "email": "sunqi@example.com"
    ]
]

for (index, testData) in testCases.enumerated() {
    print("\n=== æµ‹è¯•ç”¨ä¾‹ \(index + 1) ===")
    do {
        let profile = try validator.validateUserProfile(data: testData)
        print("âœ… éªŒè¯æˆåŠŸ:")
        print("   å§“å: \(profile.name)")
        print("   å¹´é¾„: \(profile.age)")
        print("   é‚®ç®±: \(profile.email)")
        print("   æ‰‹æœº: \(profile.phone ?? "æ— ")")
    } catch DataValidationError.missingRequiredField(let field) {
        print("âŒ ç¼ºå°‘å¿…å¡«å­—æ®µ: \(field)")
    } catch DataValidationError.outOfRange(let min, let max, let actual) {
        print("âŒ æ•°å€¼è¶…å‡ºèŒƒå›´: \(actual) (åº”åœ¨ \(min)-\(max) ä¹‹é—´)")
    } catch DataValidationError.typeMismatch(let expected, let actual) {
        print("âŒ ç±»å‹ä¸åŒ¹é…: æœŸæœ› \(expected)ï¼Œå®é™… \(actual)")
    } catch DataValidationError.invalidFormat {
        print("âŒ æ ¼å¼æ— æ•ˆ")
    } catch DataValidationError.customValidation(let message) {
        print("âŒ è‡ªå®šä¹‰éªŒè¯é”™è¯¯: \(message)")
    } catch {
        print("âŒ æœªçŸ¥é”™è¯¯: \(error)")
    }
}
```

## ğŸ“ å°ç»“

### é‡ç‚¹å›é¡¾

1. **é”™è¯¯ç±»å‹**ï¼šä½¿ç”¨Erroråè®®å®šä¹‰é”™è¯¯æšä¸¾
2. **æŠ›å‡ºé”™è¯¯**ï¼šä½¿ç”¨throwså…³é”®å­—å’Œthrowè¯­å¥
3. **æ•è·é”™è¯¯**ï¼šä½¿ç”¨do-catchè¯­å¥å¤„ç†é”™è¯¯
4. **é”™è¯¯ä¼ æ’­**ï¼šé”™è¯¯ä¼šè‡ªåŠ¨å‘è°ƒç”¨æ ˆä¸Šå±‚ä¼ æ’­
5. **tryå˜ä½“**ï¼štryã€try?ã€try!çš„ä¸åŒç”¨æ³•
6. **deferè¯­å¥**ï¼šç¡®ä¿æ¸…ç†ä»£ç ä¸€å®šæ‰§è¡Œ

### æœ€ä½³å®è·µ

- å®šä¹‰æœ‰æ„ä¹‰çš„é”™è¯¯ç±»å‹å’Œé”™è¯¯ä¿¡æ¯
- ä½¿ç”¨do-catchå¤„ç†å¯é¢„æœŸçš„é”™è¯¯
- è°¨æ…ä½¿ç”¨try!ï¼Œä»…åœ¨ç¡®å®šä¸ä¼šå¤±è´¥æ—¶ä½¿ç”¨
- å–„ç”¨deferè¿›è¡Œèµ„æºæ¸…ç†
- æä¾›æœ¬åœ°åŒ–çš„é”™è¯¯æè¿°
- é”™è¯¯å¤„ç†åº”è¯¥æ˜¯ä»£ç é€»è¾‘çš„ä¸€éƒ¨åˆ†ï¼Œè€Œä¸æ˜¯äº‹åè¡¥å……

### å¸¸è§é™·é˜±

- è¿‡åº¦ä½¿ç”¨try!å¯¼è‡´ç¨‹åºå´©æºƒ
- å¿˜è®°å¤„ç†æ‰€æœ‰å¯èƒ½çš„é”™è¯¯æƒ…å†µ
- deferè¯­å¥ä¸­çš„ä»£ç è¿‡äºå¤æ‚
- é”™è¯¯ç±»å‹è®¾è®¡ä¸åˆç†
- å¿½ç•¥é”™è¯¯ä¼ æ’­æœºåˆ¶

### é”™è¯¯å¤„ç†ç­–ç•¥

1. **å¿«é€Ÿå¤±è´¥**ï¼šå°½æ—©å‘ç°å’ŒæŠ¥å‘Šé”™è¯¯
2. **ä¼˜é›…é™çº§**ï¼šæä¾›å¤‡é€‰æ–¹æ¡ˆ
3. **ç”¨æˆ·å‹å¥½**ï¼šæä¾›æ˜“æ‡‚çš„é”™è¯¯ä¿¡æ¯
4. **æ—¥å¿—è®°å½•**ï¼šè®°å½•é”™è¯¯ç”¨äºè°ƒè¯•
5. **æ¢å¤æœºåˆ¶**ï¼šåœ¨å¯èƒ½çš„æƒ…å†µä¸‹è‡ªåŠ¨æ¢å¤

## ğŸ”„ ä¸‹ä¸€æ­¥

å®ŒæˆSwiftåŸºç¡€å­¦ä¹ åï¼Œä½ å·²ç»æŒæ¡äº†Swiftè¯­è¨€çš„æ ¸å¿ƒæ¦‚å¿µï¼ç°åœ¨å¯ä»¥ç»§ç»­å­¦ä¹ ï¼š

1. [02-é¢å‘å¯¹è±¡ç¼–ç¨‹](../02-é¢å‘å¯¹è±¡ç¼–ç¨‹/) - æ·±å…¥äº†è§£ç±»ã€ç»“æ„ä½“ã€åè®®ç­‰
2. [05-SwiftUI](../05-SwiftUI/) - å¼€å§‹æ„å»ºç”¨æˆ·ç•Œé¢
3. [å®è·µé¡¹ç›®](../examples/) - é€šè¿‡é¡¹ç›®å·©å›ºæ‰€å­¦çŸ¥è¯†

æ­å–œä½ å®Œæˆäº†SwiftåŸºç¡€è¯­æ³•çš„å­¦ä¹ ï¼ğŸ‰ 