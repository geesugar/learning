<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvasäº¤äº’æ§åˆ¶ç¤ºä¾‹</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .example-section {
            margin-bottom: 40px;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
        .example-title {
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        .description {
            background-color: #f8f9fa;
            padding: 15px;
            border-left: 4px solid #3498db;
            margin-bottom: 20px;
            border-radius: 0 5px 5px 0;
        }
        canvas {
            border: 2px solid #34495e;
            margin: 10px 0;
            display: block;
            background: white;
            cursor: crosshair;
        }
        canvas.dragging {
            cursor: grabbing;
        }
        button {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #2980b9;
        }
        .controls {
            display: flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            margin: 15px 0;
        }
        .status {
            background: #ecf0f1;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            font-size: 12px;
            margin: 10px 0;
        }
        .color-picker {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        .color-option {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            cursor: pointer;
            border: 3px solid transparent;
        }
        .color-option.active {
            border-color: #333;
        }
        .tools {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        .tool-btn {
            padding: 8px 12px;
            background: #95a5a6;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .tool-btn.active {
            background: #e74c3c;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ® Canvasäº¤äº’æ§åˆ¶ç¤ºä¾‹</h1>
        
        <!-- ç¤ºä¾‹1: é¼ æ ‡äº‹ä»¶ç®¡ç† -->
        <div class="example-section">
            <div class="example-title">1. é¼ æ ‡äº‹ä»¶ç®¡ç†</div>
            <div class="description">
                <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong>æ¼”ç¤ºé¼ æ ‡ç‚¹å‡»ã€ç§»åŠ¨ã€æ‹–æ‹½ç­‰äº‹ä»¶çš„å¤„ç†ã€‚<br>
                <strong>æŠ€æœ¯è¦ç‚¹ï¼š</strong>é¼ æ ‡äº‹ä»¶ç›‘å¬ã€åæ ‡è½¬æ¢ã€çŠ¶æ€ç®¡ç†
                <br><strong>æ“ä½œè¯´æ˜ï¼š</strong>ç‚¹å‡»åˆ›å»ºåœ†å½¢ï¼Œæ‹–æ‹½ç§»åŠ¨åœ†å½¢ï¼Œå³é”®åˆ é™¤åœ†å½¢
            </div>
            
            <canvas id="mouseCanvas" width="600" height="300"></canvas>
            
            <div class="status" id="mouseStatus">
                é¼ æ ‡çŠ¶æ€: å°±ç»ª | åæ ‡: (0, 0) | æ“ä½œ: æ— 
            </div>
            
            <div class="controls">
                <button onclick="clearCanvas('mouseCanvas')">ğŸ—‘ï¸ æ¸…é™¤ç”»å¸ƒ</button>
                <button onclick="resetMouseDemo()">ğŸ”„ é‡ç½®æ¼”ç¤º</button>
                <span>åœ†å½¢æ•°é‡: <span id="circleCount">0</span></span>
            </div>
        </div>

        <!-- ç¤ºä¾‹2: é”®ç›˜æ§åˆ¶ -->
        <div class="example-section">
            <div class="example-title">2. é”®ç›˜æ§åˆ¶ç³»ç»Ÿ</div>
            <div class="description">
                <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong>ä½¿ç”¨é”®ç›˜æ§åˆ¶å¯¹è±¡ç§»åŠ¨å’ŒçŠ¶æ€æ”¹å˜ã€‚<br>
                <strong>æŠ€æœ¯è¦ç‚¹ï¼š</strong>é”®ç›˜äº‹ä»¶ç›‘å¬ã€æŒ‰é”®çŠ¶æ€ç®¡ç†ã€å¤šé”®åŒæ—¶æ£€æµ‹
                <br><strong>æ“ä½œè¯´æ˜ï¼š</strong>WASD/æ–¹å‘é”®ç§»åŠ¨ï¼Œç©ºæ ¼é”®å˜è‰²ï¼ŒESCé‡ç½®
            </div>
            
            <canvas id="keyboardCanvas" width="600" height="300"></canvas>
            
            <div class="status" id="keyboardStatus">
                æŒ‰é”®çŠ¶æ€: æ—  | ä½ç½®: (300, 150) | é€Ÿåº¦: 5px/å¸§
            </div>
            
            <div class="controls">
                <button onclick="toggleKeyboardDemo()">â–¶ï¸ å¼€å§‹/æš‚åœ</button>
                <button onclick="resetKeyboardDemo()">ğŸ”„ é‡ç½®ä½ç½®</button>
                <span>ç„¦ç‚¹åœ¨è¿™é‡Œæ‰èƒ½æ¥æ”¶é”®ç›˜äº‹ä»¶ â†’ </span>
                <input type="text" placeholder="ç‚¹å‡»è¿™é‡Œè·å¾—ç„¦ç‚¹" style="border: 2px solid #3498db;">
            </div>
        </div>

        <!-- ç¤ºä¾‹3: é«˜çº§æ‹–æ‹½ç³»ç»Ÿ -->
        <div class="example-section">
            <div class="example-title">3. é«˜çº§æ‹–æ‹½ç³»ç»Ÿ</div>
            <div class="description">
                <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong>å®ç°ç²¾ç¡®çš„æ‹–æ‹½æ£€æµ‹ã€ç¢°æ’å¤„ç†å’Œè§†è§‰åé¦ˆã€‚<br>
                <strong>æŠ€æœ¯è¦ç‚¹ï¼š</strong>ç¢°æ’æ£€æµ‹ã€æ‹–æ‹½çŠ¶æ€ç®¡ç†ã€è§†è§‰åé¦ˆ
                <br><strong>æ“ä½œè¯´æ˜ï¼š</strong>æ‹–æ‹½ç§»åŠ¨æ–¹å—ï¼Œè§‚å¯Ÿç¢°æ’æ•ˆæœå’Œè¾¹ç•Œå¤„ç†
            </div>
            
            <canvas id="dragCanvas" width="600" height="300"></canvas>
            
            <div class="status" id="dragStatus">
                æ‹–æ‹½çŠ¶æ€: ç©ºé—² | é€‰ä¸­å¯¹è±¡: æ—  | ç¢°æ’æ£€æµ‹: å¼€å¯
            </div>
            
            <div class="controls">
                <button onclick="addDragObject()">â• æ·»åŠ æ–¹å—</button>
                <button onclick="clearDragObjects()">ğŸ—‘ï¸ æ¸…é™¤æ–¹å—</button>
                <button onclick="toggleCollision()">ğŸ”„ åˆ‡æ¢ç¢°æ’æ£€æµ‹</button>
                <span>æ–¹å—æ•°é‡: <span id="dragObjectCount">0</span></span>
            </div>
        </div>

        <!-- ç¤ºä¾‹4: ç»˜ç”»æ¿åº”ç”¨ -->
        <div class="example-section">
            <div class="example-title">4. äº¤äº’å¼ç»˜ç”»æ¿</div>
            <div class="description">
                <strong>åŠŸèƒ½è¯´æ˜ï¼š</strong>å®Œæ•´çš„ç»˜ç”»åº”ç”¨ï¼Œæ”¯æŒå¤šç§å·¥å…·å’Œé¢œè‰²é€‰æ‹©ã€‚<br>
                <strong>æŠ€æœ¯è¦ç‚¹ï¼š</strong>è·¯å¾„ç»˜åˆ¶ã€å·¥å…·åˆ‡æ¢ã€é¢œè‰²ç®¡ç†ã€æ’¤é”€åŠŸèƒ½
            </div>
            
            <div class="tools">
                <button class="tool-btn active" data-tool="brush" onclick="selectTool('brush')">ğŸ–Œï¸ ç”»ç¬”</button>
                <button class="tool-btn" data-tool="eraser" onclick="selectTool('eraser')">ğŸ§½ æ©¡çš®</button>
                <button class="tool-btn" data-tool="line" onclick="selectTool('line')">ğŸ“ ç›´çº¿</button>
                <button class="tool-btn" data-tool="circle" onclick="selectTool('circle')">â­• åœ†å½¢</button>
                <button class="tool-btn" data-tool="rect" onclick="selectTool('rect')">â¬œ çŸ©å½¢</button>
            </div>
            
            <div class="color-picker">
                <div class="color-option active" style="background: #000000;" data-color="#000000" onclick="selectColor('#000000')"></div>
                <div class="color-option" style="background: #e74c3c;" data-color="#e74c3c" onclick="selectColor('#e74c3c')"></div>
                <div class="color-option" style="background: #3498db;" data-color="#3498db" onclick="selectColor('#3498db')"></div>
                <div class="color-option" style="background: #2ecc71;" data-color="#2ecc71" onclick="selectColor('#2ecc71')"></div>
                <div class="color-option" style="background: #f39c12;" data-color="#f39c12" onclick="selectColor('#f39c12')"></div>
                <div class="color-option" style="background: #9b59b6;" data-color="#9b59b6" onclick="selectColor('#9b59b6')"></div>
            </div>
            
            <canvas id="drawCanvas" width="600" height="400"></canvas>
            
            <div class="controls">
                <button onclick="undoDraw()">â†¶ æ’¤é”€</button>
                <button onclick="clearDrawCanvas()">ğŸ—‘ï¸ æ¸…ç©º</button>
                <button onclick="saveDrawing()">ğŸ’¾ ä¿å­˜</button>
                <label>ç¬”åˆ·å¤§å°: <input type="range" id="brushSize" min="1" max="50" value="5" oninput="updateBrushSize()"></label>
                <span id="brushSizeValue">5px</span>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let mouseCircles = [];
        let keyboardObject = { x: 300, y: 150, color: '#e74c3c', size: 30 };
        let keyboardAnimation = false;
        let keys = {};
        let dragObjects = [];
        let dragState = { isDragging: false, dragObject: null, offset: { x: 0, y: 0 } };
        let collisionEnabled = true;
        
        // ç»˜ç”»æ¿å˜é‡
        let currentTool = 'brush';
        let currentColor = '#000000';
        let brushSize = 5;
        let isDrawing = false;
        let drawingHistory = [];
        let drawPath = [];
        let startPoint = null;
        
        // é¼ æ ‡äº‹ä»¶ç®¡ç†ç¤ºä¾‹
        function initMouseDemo() {
            const canvas = document.getElementById('mouseCanvas');
            const ctx = canvas.getContext('2d');
            
            // é¼ æ ‡ç§»åŠ¨äº‹ä»¶
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                document.getElementById('mouseStatus').textContent = 
                    `é¼ æ ‡çŠ¶æ€: ç§»åŠ¨ä¸­ | åæ ‡: (${Math.round(x)}, ${Math.round(y)}) | æ“ä½œ: è·Ÿè¸ª`;
            });
            
            // é¼ æ ‡ç‚¹å‡»äº‹ä»¶
            canvas.addEventListener('click', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // åˆ›å»ºæ–°çš„åœ†å½¢
                const circle = {
                    x: x,
                    y: y,
                    radius: 20 + Math.random() * 20,
                    color: `hsl(${Math.random() * 360}, 70%, 60%)`,
                    isDragging: false
                };
                
                mouseCircles.push(circle);
                updateCircleCount();
                drawMouseCircles();
                
                document.getElementById('mouseStatus').textContent = 
                    `é¼ æ ‡çŠ¶æ€: ç‚¹å‡» | åæ ‡: (${Math.round(x)}, ${Math.round(y)}) | æ“ä½œ: åˆ›å»ºåœ†å½¢`;
            });
            
            // å³é”®åˆ é™¤
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æŸ¥æ‰¾ç‚¹å‡»çš„åœ†å½¢
                for (let i = mouseCircles.length - 1; i >= 0; i--) {
                    const circle = mouseCircles[i];
                    const dist = Math.sqrt((x - circle.x) ** 2 + (y - circle.y) ** 2);
                    if (dist <= circle.radius) {
                        mouseCircles.splice(i, 1);
                        updateCircleCount();
                        drawMouseCircles();
                        break;
                    }
                }
                
                document.getElementById('mouseStatus').textContent = 
                    `é¼ æ ‡çŠ¶æ€: å³é”®ç‚¹å‡» | åæ ‡: (${Math.round(x)}, ${Math.round(y)}) | æ“ä½œ: åˆ é™¤åœ†å½¢`;
            });
            
            // æ‹–æ‹½åŠŸèƒ½
            let dragCircle = null;
            let dragOffset = { x: 0, y: 0 };
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // æŸ¥æ‰¾å¯æ‹–æ‹½çš„åœ†å½¢
                for (let circle of mouseCircles) {
                    const dist = Math.sqrt((x - circle.x) ** 2 + (y - circle.y) ** 2);
                    if (dist <= circle.radius) {
                        dragCircle = circle;
                        dragOffset.x = x - circle.x;
                        dragOffset.y = y - circle.y;
                        circle.isDragging = true;
                        canvas.style.cursor = 'grabbing';
                        break;
                    }
                }
            });
            
            canvas.addEventListener('mousemove', (e) => {
                if (dragCircle) {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    dragCircle.x = x - dragOffset.x;
                    dragCircle.y = y - dragOffset.y;
                    
                    // è¾¹ç•Œæ£€æµ‹
                    dragCircle.x = Math.max(dragCircle.radius, Math.min(canvas.width - dragCircle.radius, dragCircle.x));
                    dragCircle.y = Math.max(dragCircle.radius, Math.min(canvas.height - dragCircle.radius, dragCircle.y));
                    
                    drawMouseCircles();
                    
                    document.getElementById('mouseStatus').textContent = 
                        `é¼ æ ‡çŠ¶æ€: æ‹–æ‹½ä¸­ | åæ ‡: (${Math.round(x)}, ${Math.round(y)}) | æ“ä½œ: ç§»åŠ¨åœ†å½¢`;
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                if (dragCircle) {
                    dragCircle.isDragging = false;
                    dragCircle = null;
                    canvas.style.cursor = 'crosshair';
                }
            });
        }
        
        function drawMouseCircles() {
            const canvas = document.getElementById('mouseCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            mouseCircles.forEach(circle => {
                // ç»˜åˆ¶åœ†å½¢
                ctx.fillStyle = circle.color;
                ctx.beginPath();
                ctx.arc(circle.x, circle.y, circle.radius, 0, 2 * Math.PI);
                ctx.fill();
                
                // å¦‚æœæ­£åœ¨æ‹–æ‹½ï¼Œæ·»åŠ è¾¹æ¡†
                if (circle.isDragging) {
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                // æ·»åŠ é«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.beginPath();
                ctx.arc(circle.x - circle.radius * 0.3, circle.y - circle.radius * 0.3, circle.radius * 0.3, 0, 2 * Math.PI);
                ctx.fill();
            });
        }
        
        function updateCircleCount() {
            document.getElementById('circleCount').textContent = mouseCircles.length;
        }
        
        function resetMouseDemo() {
            mouseCircles = [];
            updateCircleCount();
            drawMouseCircles();
            document.getElementById('mouseStatus').textContent = 
                'é¼ æ ‡çŠ¶æ€: å°±ç»ª | åæ ‡: (0, 0) | æ“ä½œ: æ— ';
        }
        
        // é”®ç›˜æ§åˆ¶ç¤ºä¾‹
        function initKeyboardDemo() {
            // é”®ç›˜äº‹ä»¶ç›‘å¬
            document.addEventListener('keydown', (e) => {
                keys[e.key.toLowerCase()] = true;
                
                // ç‰¹æ®ŠæŒ‰é”®å¤„ç†
                if (e.key === ' ') {
                    e.preventDefault();
                    keyboardObject.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                }
                
                if (e.key === 'Escape') {
                    keyboardObject.x = 300;
                    keyboardObject.y = 150;
                }
                
                updateKeyboardStatus();
            });
            
            document.addEventListener('keyup', (e) => {
                keys[e.key.toLowerCase()] = false;
                updateKeyboardStatus();
            });
        }
        
        function updateKeyboardObject() {
            const canvas = document.getElementById('keyboardCanvas');
            const speed = 5;
            
            // WASD æˆ– æ–¹å‘é”®ç§»åŠ¨
            if (keys['w'] || keys['arrowup']) keyboardObject.y -= speed;
            if (keys['s'] || keys['arrowdown']) keyboardObject.y += speed;
            if (keys['a'] || keys['arrowleft']) keyboardObject.x -= speed;
            if (keys['d'] || keys['arrowright']) keyboardObject.x += speed;
            
            // è¾¹ç•Œæ£€æµ‹
            keyboardObject.x = Math.max(keyboardObject.size, Math.min(canvas.width - keyboardObject.size, keyboardObject.x));
            keyboardObject.y = Math.max(keyboardObject.size, Math.min(canvas.height - keyboardObject.size, keyboardObject.y));
            
            drawKeyboardObject();
        }
        
        function drawKeyboardObject() {
            const canvas = document.getElementById('keyboardCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶æ§åˆ¶å¯¹è±¡
            ctx.fillStyle = keyboardObject.color;
            ctx.fillRect(
                keyboardObject.x - keyboardObject.size / 2,
                keyboardObject.y - keyboardObject.size / 2,
                keyboardObject.size,
                keyboardObject.size
            );
            
            // ç»˜åˆ¶æ–¹å‘æŒ‡ç¤ºå™¨
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(keyboardObject.x, keyboardObject.y - keyboardObject.size / 2 - 10);
            ctx.lineTo(keyboardObject.x, keyboardObject.y - keyboardObject.size / 2 - 20);
            ctx.stroke();
            
            // ç»˜åˆ¶æŒ‰é”®æç¤º
            ctx.fillStyle = '#666';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('WASD/æ–¹å‘é”®ç§»åŠ¨', canvas.width / 2, 30);
            ctx.fillText('ç©ºæ ¼é”®å˜è‰², ESCé‡ç½®', canvas.width / 2, 50);
        }
        
        function updateKeyboardStatus() {
            const activeKeys = Object.keys(keys).filter(key => keys[key]);
            const keyText = activeKeys.length > 0 ? activeKeys.join(', ') : 'æ— ';
            
            document.getElementById('keyboardStatus').textContent = 
                `æŒ‰é”®çŠ¶æ€: ${keyText} | ä½ç½®: (${Math.round(keyboardObject.x)}, ${Math.round(keyboardObject.y)}) | é€Ÿåº¦: 5px/å¸§`;
        }
        
        let keyboardAnimationId;
        
        function toggleKeyboardDemo() {
            if (!keyboardAnimation) {
                keyboardAnimation = true;
                startKeyboardAnimation();
            } else {
                keyboardAnimation = false;
                if (keyboardAnimationId) {
                    cancelAnimationFrame(keyboardAnimationId);
                }
            }
        }
        
        function startKeyboardAnimation() {
            function animate() {
                if (!keyboardAnimation) return;
                
                updateKeyboardObject();
                keyboardAnimationId = requestAnimationFrame(animate);
            }
            animate();
        }
        
        function resetKeyboardDemo() {
            keyboardObject.x = 300;
            keyboardObject.y = 150;
            keyboardObject.color = '#e74c3c';
            drawKeyboardObject();
        }
        
        // é«˜çº§æ‹–æ‹½ç³»ç»Ÿ
        function initDragDemo() {
            const canvas = document.getElementById('dragCanvas');
            
            // åˆå§‹åŒ–ä¸€äº›æ‹–æ‹½å¯¹è±¡
            for (let i = 0; i < 3; i++) {
                addDragObject();
            }
            
            canvas.addEventListener('mousedown', handleDragStart);
            canvas.addEventListener('mousemove', handleDragMove);
            canvas.addEventListener('mouseup', handleDragEnd);
        }
        
        function addDragObject() {
            const canvas = document.getElementById('dragCanvas');
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6'];
            
            const obj = {
                x: Math.random() * (canvas.width - 100) + 50,
                y: Math.random() * (canvas.height - 100) + 50,
                width: 60,
                height: 60,
                color: colors[Math.floor(Math.random() * colors.length)],
                isDragging: false,
                isHovered: false
            };
            
            dragObjects.push(obj);
            updateDragObjectCount();
            drawDragObjects();
        }
        
        function handleDragStart(e) {
            const canvas = document.getElementById('dragCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ä»ä¸Šåˆ°ä¸‹æ£€æŸ¥å¯¹è±¡
            for (let i = dragObjects.length - 1; i >= 0; i--) {
                const obj = dragObjects[i];
                if (x >= obj.x && x <= obj.x + obj.width && 
                    y >= obj.y && y <= obj.y + obj.height) {
                    
                    dragState.isDragging = true;
                    dragState.dragObject = obj;
                    dragState.offset.x = x - obj.x;
                    dragState.offset.y = y - obj.y;
                    
                    obj.isDragging = true;
                    canvas.classList.add('dragging');
                    
                    // ç§»åˆ°æœ€å‰é¢
                    dragObjects.splice(i, 1);
                    dragObjects.push(obj);
                    
                    drawDragObjects();
                    break;
                }
            }
            
            updateDragStatus();
        }
        
        function handleDragMove(e) {
            const canvas = document.getElementById('dragCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (dragState.isDragging && dragState.dragObject) {
                const obj = dragState.dragObject;
                obj.x = x - dragState.offset.x;
                obj.y = y - dragState.offset.y;
                
                // è¾¹ç•Œæ£€æµ‹
                obj.x = Math.max(0, Math.min(canvas.width - obj.width, obj.x));
                obj.y = Math.max(0, Math.min(canvas.height - obj.height, obj.y));
                
                // ç¢°æ’æ£€æµ‹
                if (collisionEnabled) {
                    checkCollisions(obj);
                }
                
                drawDragObjects();
            } else {
                // æ‚¬åœæ£€æµ‹
                let hoveredObj = null;
                for (let obj of dragObjects) {
                    const isHovered = x >= obj.x && x <= obj.x + obj.width && 
                                     y >= obj.y && y <= obj.y + obj.height;
                    if (isHovered) {
                        hoveredObj = obj;
                    }
                    obj.isHovered = isHovered;
                }
                
                canvas.style.cursor = hoveredObj ? 'grab' : 'default';
                drawDragObjects();
            }
            
            updateDragStatus();
        }
        
        function handleDragEnd() {
            if (dragState.isDragging && dragState.dragObject) {
                dragState.dragObject.isDragging = false;
                dragState.isDragging = false;
                dragState.dragObject = null;
                
                const canvas = document.getElementById('dragCanvas');
                canvas.classList.remove('dragging');
                canvas.style.cursor = 'default';
                
                drawDragObjects();
            }
            
            updateDragStatus();
        }
        
        function checkCollisions(obj) {
            for (let other of dragObjects) {
                if (other === obj) continue;
                
                if (obj.x < other.x + other.width &&
                    obj.x + obj.width > other.x &&
                    obj.y < other.y + other.height &&
                    obj.y + obj.height > other.y) {
                    
                    // ç®€å•çš„æ¨æŒ¤æ•ˆæœ
                    const centerX1 = obj.x + obj.width / 2;
                    const centerY1 = obj.y + obj.height / 2;
                    const centerX2 = other.x + other.width / 2;
                    const centerY2 = other.y + other.height / 2;
                    
                    const dx = centerX1 - centerX2;
                    const dy = centerY1 - centerY2;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0) {
                        const pushDistance = 5;
                        other.x -= (dx / distance) * pushDistance;
                        other.y -= (dy / distance) * pushDistance;
                        
                        // è¾¹ç•Œæ£€æµ‹
                        const canvas = document.getElementById('dragCanvas');
                        other.x = Math.max(0, Math.min(canvas.width - other.width, other.x));
                        other.y = Math.max(0, Math.min(canvas.height - other.height, other.y));
                    }
                }
            }
        }
        
        function drawDragObjects() {
            const canvas = document.getElementById('dragCanvas');
            const ctx = canvas.getContext('2d');
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            dragObjects.forEach(obj => {
                // ç»˜åˆ¶é˜´å½±
                if (obj.isDragging) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fillRect(obj.x + 5, obj.y + 5, obj.width, obj.height);
                }
                
                // ç»˜åˆ¶å¯¹è±¡
                ctx.fillStyle = obj.color;
                ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
                
                // æ‚¬åœæˆ–æ‹–æ‹½çŠ¶æ€çš„è¾¹æ¡†
                if (obj.isHovered || obj.isDragging) {
                    ctx.strokeStyle = obj.isDragging ? '#e74c3c' : '#3498db';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(obj.x, obj.y, obj.width, obj.height);
                }
                
                // ç»˜åˆ¶é«˜å…‰
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fillRect(obj.x, obj.y, obj.width / 3, obj.height / 3);
            });
        }
        
        function updateDragStatus() {
            const status = dragState.isDragging ? 'æ‹–æ‹½ä¸­' : 'ç©ºé—²';
            const selected = dragState.dragObject ? 'æœ‰' : 'æ— ';
            const collision = collisionEnabled ? 'å¼€å¯' : 'å…³é—­';
            
            document.getElementById('dragStatus').textContent = 
                `æ‹–æ‹½çŠ¶æ€: ${status} | é€‰ä¸­å¯¹è±¡: ${selected} | ç¢°æ’æ£€æµ‹: ${collision}`;
        }
        
        function updateDragObjectCount() {
            document.getElementById('dragObjectCount').textContent = dragObjects.length;
        }
        
        function clearDragObjects() {
            dragObjects = [];
            updateDragObjectCount();
            drawDragObjects();
            updateDragStatus();
        }
        
        function toggleCollision() {
            collisionEnabled = !collisionEnabled;
            updateDragStatus();
        }
        
        // ç»˜ç”»æ¿åŠŸèƒ½
        function initDrawingBoard() {
            const canvas = document.getElementById('drawCanvas');
            
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);
            
            // ä¿å­˜åˆå§‹çŠ¶æ€
            saveDrawingState();
        }
        
        function startDrawing(e) {
            const canvas = document.getElementById('drawCanvas');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            isDrawing = true;
            startPoint = { x, y };
            
            if (currentTool === 'brush' || currentTool === 'eraser') {
                drawPath = [{ x, y }];
            }
        }
        
        function draw(e) {
            if (!isDrawing) return;
            
            const canvas = document.getElementById('drawCanvas');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentTool === 'brush') {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (drawPath.length > 1) {
                    ctx.beginPath();
                    ctx.moveTo(drawPath[drawPath.length - 2].x, drawPath[drawPath.length - 2].y);
                    ctx.lineTo(x, y);
                    ctx.stroke();
                }
                
                drawPath.push({ x, y });
            } else if (currentTool === 'eraser') {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.beginPath();
                ctx.arc(x, y, brushSize, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
        
        function stopDrawing(e) {
            if (!isDrawing) return;
            
            isDrawing = false;
            
            const canvas = document.getElementById('drawCanvas');
            const ctx = canvas.getContext('2d');
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // ç»˜åˆ¶å½¢çŠ¶å·¥å…·
            if (currentTool === 'line' && startPoint) {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.beginPath();
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.lineTo(x, y);
                ctx.stroke();
            } else if (currentTool === 'circle' && startPoint) {
                const radius = Math.sqrt(Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2));
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.beginPath();
                ctx.arc(startPoint.x, startPoint.y, radius, 0, 2 * Math.PI);
                ctx.stroke();
            } else if (currentTool === 'rect' && startPoint) {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = brushSize;
                ctx.strokeRect(startPoint.x, startPoint.y, x - startPoint.x, y - startPoint.y);
            }
            
            // ä¿å­˜çŠ¶æ€
            saveDrawingState();
            drawPath = [];
            startPoint = null;
        }
        
        function selectTool(tool) {
            currentTool = tool;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-tool="${tool}"]`).classList.add('active');
        }
        
        function selectColor(color) {
            currentColor = color;
            
            // æ›´æ–°é¢œè‰²é€‰æ‹©å™¨çŠ¶æ€
            document.querySelectorAll('.color-option').forEach(option => {
                option.classList.remove('active');
            });
            document.querySelector(`[data-color="${color}"]`).classList.add('active');
        }
        
        function updateBrushSize() {
            brushSize = parseInt(document.getElementById('brushSize').value);
            document.getElementById('brushSizeValue').textContent = brushSize + 'px';
        }
        
        function saveDrawingState() {
            const canvas = document.getElementById('drawCanvas');
            drawingHistory.push(canvas.toDataURL());
            
            // é™åˆ¶å†å²è®°å½•æ•°é‡
            if (drawingHistory.length > 20) {
                drawingHistory.shift();
            }
        }
        
        function undoDraw() {
            if (drawingHistory.length > 1) {
                drawingHistory.pop(); // ç§»é™¤å½“å‰çŠ¶æ€
                const previousState = drawingHistory[drawingHistory.length - 1];
                
                const canvas = document.getElementById('drawCanvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = function() {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                };
                img.src = previousState;
            }
        }
        
        function clearDrawCanvas() {
            const canvas = document.getElementById('drawCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawingHistory = [];
            saveDrawingState();
        }
        
        function saveDrawing() {
            const canvas = document.getElementById('drawCanvas');
            const link = document.createElement('a');
            link.download = 'canvas-drawing.png';
            link.href = canvas.toDataURL();
            link.click();
        }
        
        // æ¸…é™¤ç”»å¸ƒé€šç”¨å‡½æ•°
        function clearCanvas(canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–æ‰€æœ‰ç¤ºä¾‹
        window.addEventListener('load', function() {
            initMouseDemo();
            initKeyboardDemo();
            initDragDemo();
            initDrawingBoard();
            
            drawMouseCircles();
            drawKeyboardObject();
            drawDragObjects();
            
            console.log('Canvasäº¤äº’æ§åˆ¶ç¤ºä¾‹é¡µé¢åŠ è½½å®Œæˆ');
        });
    </script>
</body>
</html> 