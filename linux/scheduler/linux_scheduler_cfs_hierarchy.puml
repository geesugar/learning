@startuml CFS任务组层次化调度详细时序图
!theme blueprint
title CFS任务组层次化调度详细流程

participant "根CFS队列\n(root cfs_rq)" as RootCFS
participant "任务组A\n(tg_A)" as TGA
participant "任务组A的SE\n(tg_A->se[cpu])" as TGA_SE
participant "任务组A的队列\n(tg_A->cfs_rq[cpu])" as TGA_CFS
participant "任务组B\n(tg_B)" as TGB
participant "任务组B的SE\n(tg_B->se[cpu])" as TGB_SE
participant "任务组B的队列\n(tg_B->cfs_rq[cpu])" as TGB_CFS
participant "具体任务1\n(task1)" as Task1
participant "具体任务2\n(task2)" as Task2
participant "虚拟运行时间\n(vruntime)" as VRT

== 层次结构初始化 ==

note over RootCFS: CPU的根CFS运行队列
RootCFS -> TGA: 包含任务组A的调度实体
RootCFS -> TGB: 包含任务组B的调度实体

TGA -> TGA_SE: se->my_q = tg_A->cfs_rq[cpu]
TGA -> TGA_CFS: cfs_rq->tg = tg_A
TGA_CFS -> Task1: 包含具体任务1
TGA_CFS -> Task2: 包含具体任务2

TGB -> TGB_SE: se->my_q = tg_B->cfs_rq[cpu]
TGB -> TGB_CFS: cfs_rq->tg = tg_B

== 调度决策开始 ==

note over RootCFS: pick_next_task_fair()开始

RootCFS -> RootCFS: 在根队列中选择
note over RootCFS: 比较tg_A->se和tg_B->se的vruntime

== 任务组间调度 ==

RootCFS -> TGA_SE: 检查vruntime
TGA_SE -> VRT: se->vruntime = 1000
VRT -> TGA_SE: 返回vruntime值

RootCFS -> TGB_SE: 检查vruntime  
TGB_SE -> VRT: se->vruntime = 1200
VRT -> TGB_SE: 返回vruntime值

RootCFS -> RootCFS: 比较: tg_A(1000) < tg_B(1200)
note over RootCFS: 选择任务组A（vruntime更小）

== 进入选中的任务组 ==

RootCFS -> TGA_SE: 选中任务组A的SE
TGA_SE -> TGA_CFS: 进入任务组A的内部队列
note over TGA_CFS: 现在在tg_A->cfs_rq[cpu]中选择

== 任务组内调度 ==

TGA_CFS -> Task1: 检查task1的vruntime
Task1 -> VRT: se->vruntime = 500
VRT -> Task1: 返回vruntime

TGA_CFS -> Task2: 检查task2的vruntime
Task2 -> VRT: se->vruntime = 300  
VRT -> Task2: 返回vruntime

TGA_CFS -> TGA_CFS: 比较: task2(300) < task1(500)
note over TGA_CFS: 选择task2（vruntime更小）

== 最终任务选择 ==

TGA_CFS -> Task2: 选中task2执行
Task2 -> TGA_CFS: 返回task_struct

== 层次化vruntime更新 ==

note over VRT: 任务执行后更新vruntime

Task2 -> VRT: 执行时间delta = 5ms
VRT -> VRT: 计算vruntime增量
note over VRT: delta_vruntime = 5ms * (1024/task2.weight)

VRT -> Task2: 更新task2.vruntime += delta_vruntime
Task2 -> TGA_CFS: vruntime更新完成

== 组SE的vruntime更新 ==

TGA_CFS -> TGA_SE: 更新组SE的vruntime
note over TGA_SE: 组SE的vruntime基于组内最小vruntime

TGA_SE -> VRT: 计算组SE的新vruntime
VRT -> TGA_SE: 返回更新后的组vruntime

TGA_SE -> RootCFS: 将组SE重新加入根队列
note over RootCFS: 根据新vruntime重新排序

== 权重和份额处理 ==

group 任务组权重计算
    TGA -> TGA: shares = 1024 (默认权重)
    TGA -> TGA_SE: se->load.weight = shares
    
    TGB -> TGB: shares = 512 (一半权重)  
    TGB -> TGB_SE: se->load.weight = shares
    
    note over RootCFS: 任务组A获得更多CPU时间
end

== 带宽控制检查 ==

group 带宽限制处理
    TGA_CFS -> TGA: 检查cfs_bandwidth配额
    TGA -> TGA: quota = 50ms, period = 100ms
    TGA -> TGA_CFS: 检查runtime_remaining
    
    alt 配额耗尽
        TGA -> TGA_CFS: throttle_cfs_rq()
        TGA_CFS -> Task1: dequeue_entity()
        TGA_CFS -> Task2: dequeue_entity()
        note over TGA_CFS: 任务组被节流
        
        TGA_SE -> RootCFS: 从根队列移除组SE
        
    else 配额充足
        TGA -> TGA_CFS: 继续正常调度
    end
end

== 多CPU协调 ==

group 跨CPU负载均衡
    note over RootCFS: CPU0上的任务组A很忙
    
    RootCFS -> TGA: 检查其他CPU上的负载
    TGA -> TGA: CPU1上的tg_A->cfs_rq[1]较空闲
    
    TGA -> Task1: 考虑迁移task1到CPU1
    Task1 -> TGA: 检查CPU亲和性和缓存热度
    
    opt 满足迁移条件
        TGA -> TGA: 从CPU0的tg_A->cfs_rq[0]移除
        TGA -> TGA: 加入CPU1的tg_A->cfs_rq[1]
        note over TGA: 任务在任务组内跨CPU迁移
    end
end

== 调度域协调 ==

group 调度域层次处理
    note over RootCFS: SMT域内的调度决策
    RootCFS -> RootCFS: 检查超线程sibling CPU
    
    note over RootCFS: LLC域内的负载均衡
    RootCFS -> RootCFS: 在共享L3缓存的CPU间均衡
    
    note over RootCFS: NUMA域的任务迁移
    RootCFS -> RootCFS: 跨NUMA节点的慎重迁移
end

@enduml 