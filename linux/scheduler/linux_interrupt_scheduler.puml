@startuml linux_interrupt_scheduler
!theme cerulean
title Linux内核中断处理与调度器交互时序图

actor "硬件设备" as Hardware
participant "中断控制器" as IC
participant "硬件中断处理\n(上半部)" as HardIRQ
participant "软中断处理\n(下半部)" as SoftIRQ
participant "调度器核心" as Scheduler
participant "进程上下文" as Process
participant "信号处理" as Signal

== 硬件中断产生与处理 ==

Hardware -> IC: 硬件中断信号
activate IC
note right: 网卡数据包到达\n磁盘I/O完成\n定时器到期

IC -> HardIRQ: 触发中断向量
activate HardIRQ
note right: 进入中断上下文\nlocal_irq_disable()

HardIRQ -> HardIRQ: 保存进程上下文
note right: 保存寄存器状态

HardIRQ -> HardIRQ: 确认中断(ACK)
note right: 告知硬件中断已接收

alt 网络中断处理
    HardIRQ -> HardIRQ: 读取网卡状态
    HardIRQ -> HardIRQ: 快速数据预处理
    HardIRQ -> SoftIRQ: raise_softirq(NET_RX_SOFTIRQ)
    note right: 标记网络接收软中断
else 时钟中断处理
    HardIRQ -> Scheduler: scheduler_tick()
    activate Scheduler
    Scheduler -> Scheduler: 更新进程时间统计
    Scheduler -> Scheduler: 检查时间片是否用完
    Scheduler -> Scheduler: 检查是否需要抢占
    alt 需要负载均衡
        Scheduler -> SoftIRQ: raise_softirq(SCHED_SOFTIRQ)
        note right: 标记调度软中断
    end
    deactivate Scheduler
else 磁盘中断处理
    HardIRQ -> HardIRQ: 读取磁盘状态
    HardIRQ -> SoftIRQ: raise_softirq(BLOCK_SOFTIRQ)
    note right: 标记块设备软中断
end

HardIRQ -> HardIRQ: 恢复进程上下文
deactivate HardIRQ

== 中断退出与软中断处理 ==

HardIRQ -> SoftIRQ: irq_exit()
activate SoftIRQ
note right: 检查软中断标志位

alt 有待处理的软中断
    SoftIRQ -> SoftIRQ: __do_softirq()
    note right: 进入软中断上下文\n__local_bh_disable()
    
    loop 处理每个软中断类型
        alt NET_RX_SOFTIRQ
            SoftIRQ -> SoftIRQ: 网络数据包处理
            note right: 协议栈处理\n数据包分发到socket
        else TIMER_SOFTIRQ
            SoftIRQ -> SoftIRQ: 定时器回调处理
            note right: 执行定时器回调函数
        else SCHED_SOFTIRQ
            SoftIRQ -> Scheduler: run_rebalance_domains()
            activate Scheduler
            Scheduler -> Scheduler: 执行负载均衡
            Scheduler -> Scheduler: 任务迁移
            deactivate Scheduler
        else BLOCK_SOFTIRQ
            SoftIRQ -> SoftIRQ: 块设备I/O完成处理
            note right: 唤醒等待I/O的进程
        end
    end
    
    SoftIRQ -> SoftIRQ: __local_bh_enable()
    note right: 退出软中断上下文
end

SoftIRQ -> Scheduler: 检查need_resched()
alt 需要调度
    SoftIRQ -> Scheduler: schedule()
    note right: 触发进程调度
end
deactivate SoftIRQ

== 信号处理与调度的关系 ==

Process -> Signal: 接收信号
activate Signal
activate Process

Signal -> Signal: 检查进程状态
alt 进程处于TASK_INTERRUPTIBLE
    Signal -> Process: 设置信号待处理标志
    Signal -> Scheduler: wake_up_process()
    activate Scheduler
    Scheduler -> Scheduler: 将进程设为TASK_RUNNING
    Scheduler -> Scheduler: 加入运行队列
    deactivate Scheduler
else 进程处于TASK_UNINTERRUPTIBLE
    alt 致命信号(SIGKILL)
        Signal -> Process: 强制唤醒进程
        Signal -> Scheduler: wake_up_process()
        activate Scheduler
        Scheduler -> Scheduler: 设为TASK_RUNNING
        deactivate Scheduler
    else 普通信号
        Signal -> Signal: 信号被忽略
        note right: 不可中断睡眠\n不响应普通信号
    end
end
deactivate Signal

== 调度器检查信号与抢占 ==

Scheduler -> Scheduler: __schedule()
activate Scheduler

Scheduler -> Signal: signal_pending_state()
activate Signal
alt 有待处理信号且进程可中断
    Signal -> Scheduler: 返回true
    Scheduler -> Scheduler: 设置进程为TASK_RUNNING
else 无信号或进程不可中断
    Signal -> Scheduler: 返回false
end
deactivate Signal

Scheduler -> Scheduler: 选择下一个进程
note right: pick_next_task()

alt 发生进程切换
    Scheduler -> Process: context_switch()
    note right: 保存当前进程状态\n恢复新进程状态\n切换内存空间
end

deactivate Scheduler
deactivate Process

== 进程返回用户空间时的信号处理 ==

Process -> Process: 从内核返回用户空间
activate Process

Process -> Signal: 检查信号队列
activate Signal

alt 有待处理信号
    Signal -> Signal: do_signal()
    note right: 在用户空间执行\n信号处理函数
    
    alt 信号处理函数存在
        Signal -> Process: 跳转到用户信号处理函数
    else 默认信号处理
        alt SIGTERM/SIGINT
            Signal -> Process: 终止进程
        else SIGSTOP
            Signal -> Scheduler: 设置TASK_STOPPED
        else SIGCONT
            Signal -> Scheduler: 设置TASK_RUNNING
        end
    end
end

deactivate Signal
deactivate Process

@enduml 