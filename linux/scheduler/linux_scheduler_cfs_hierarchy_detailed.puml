@startuml CFS层次化调度详细时序图
!theme cerulean
title Linux CFS层次化调度详细流程

participant "时钟中断" as Timer
participant "调度器核心" as Core
participant "根CFS队列\n(root_cfs_rq)" as RootCFS
participant "任务组A\n(tg_A->se)" as TGA_SE  
participant "任务组A队列\n(tg_A->cfs_rq)" as TGA_CFS
participant "任务组B\n(tg_B->se)" as TGB_SE
participant "任务组B队列\n(tg_B->cfs_rq)" as TGB_CFS
participant "具体任务1\n(task1->se)" as Task1
participant "具体任务2\n(task2->se)" as Task2

== 时钟中断触发调度检查 ==

Timer -> Core: scheduler_tick()
activate Core

Core -> Core: task_tick_fair(curr_task)
note right: 对当前任务的每个调度实体层次\n调用entity_tick()

Core -> Core: 检查是否需要抢占
note right: check_preempt_tick()

alt 需要重新调度
    Core -> Core: resched_curr(rq)
    note right: 设置重调度标志
end

Core -> Core: trigger_load_balance(rq)
note right: 触发负载均衡检查

== 调度决策开始 ==

note over Core: schedule() 或 pick_next_task_fair()
Core -> RootCFS: 开始从根队列选择

== 第一层：任务组间调度 ==

RootCFS -> RootCFS: pick_next_entity(root_cfs_rq)
note right: 从根队列的红黑树中选择\nvruntime最小的实体

RootCFS -> TGA_SE: 检查任务组A的vruntime
TGA_SE -> RootCFS: return se->vruntime = 1000

RootCFS -> TGB_SE: 检查任务组B的vruntime  
TGB_SE -> RootCFS: return se->vruntime = 1200

RootCFS -> RootCFS: 比较vruntime
note right: tg_A(1000) < tg_B(1200)\n选择任务组A

RootCFS -> TGA_SE: 选中任务组A
note right: se = tg_A->se[cpu]

== 第二层：进入选中任务组 ==

TGA_SE -> TGA_CFS: 检查是否为组实体
note right: if (!entity_is_task(se))\n    cfs_rq = group_cfs_rq(se)

TGA_SE -> TGA_CFS: 进入任务组A的内部队列
activate TGA_CFS
note right: 现在在tg_A->cfs_rq[cpu]中选择

== 第三层：任务组内调度 ==

TGA_CFS -> TGA_CFS: pick_next_entity(tg_A->cfs_rq)
note right: 在任务组A的红黑树中选择

TGA_CFS -> Task1: 检查task1的vruntime
Task1 -> TGA_CFS: return se->vruntime = 500

TGA_CFS -> Task2: 检查task2的vruntime
Task2 -> TGA_CFS: return se->vruntime = 300

TGA_CFS -> TGA_CFS: 比较vruntime
note right: task2(300) < task1(500)\n选择task2

TGA_CFS -> Task2: 选中task2
note right: se = &task2->se

== 第四层：确认叶子任务 ==

TGA_CFS -> Task2: 检查是否为叶子任务
note right: entity_is_task(se) == true

TGA_CFS -> Core: 返回选中的任务
deactivate TGA_CFS
note right: return task_of(se) = task2

== 更新调度状态 ==

Core -> Core: set_next_task_fair(task2)
note right: 设置task2为下一个运行任务

Core -> Task2: 更新vruntime
note right: 根据运行时间更新虚拟运行时间

Core -> TGA_CFS: 更新min_vruntime
note right: 更新任务组A队列的最小vruntime

Core -> RootCFS: 更新层次统计
note right: 更新各层次的负载和统计信息

== 上下文切换 ==

Core -> Core: context_switch(prev, task2)
note right: 执行实际的上下文切换

deactivate Core

== 任务运行期间的时钟管理 ==

note over Timer: 定期时钟中断

Timer -> Core: scheduler_tick()
activate Core

Core -> Task2: entity_tick(cfs_rq, se, queued)
note right: 更新当前运行任务的统计信息

loop 遍历调度实体层次
    Core -> Core: for_each_sched_entity(se)
    note right: se = se->parent
    
    Core -> Core: entity_tick(parent_cfs_rq, parent_se)
    note right: 更新父层次的统计信息
end

Core -> Core: check_preempt_tick()
note right: 检查是否达到时间片或\n有更高优先级任务

alt 需要抢占
    Core -> Core: resched_curr(rq)
    note right: 标记需要重新调度
end

deactivate Core

@enduml 