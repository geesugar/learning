@startuml linux_scheduler
!theme cerulean
title Linux 5.15 内核调度器时序图

actor "用户空间" as User
participant "系统调用" as Syscall
participant "硬件中断" as HardIRQ
participant "软中断" as SoftIRQ
participant "调度器核心" as SchedCore
participant "调度器类" as SchedClass
participant "运行队列" as RunQueue
participant "负载均衡" as LoadBalance
participant "CPU选择" as CPUSelect
participant "上下文切换" as Context
participant "信号处理" as Signal

== 进程创建与调度 ==

User -> Syscall: fork()/execve()
activate Syscall

Syscall -> SchedCore: wake_up_new_task()
activate SchedCore

SchedCore -> CPUSelect: select_task_rq()
activate CPUSelect

CPUSelect -> CPUSelect: check_cpu_affinity()
note right: 检查CPU亲和性掩码

CPUSelect -> CPUSelect: find_idlest_cpu()
note right: 查找最空闲的CPU

alt 如果有空闲CPU
    CPUSelect -> CPUSelect: select_idle_sibling()
    note right: 选择空闲兄弟CPU
else 负载均衡
    CPUSelect -> LoadBalance: find_busiest_group()
    LoadBalance -> CPUSelect: best_cpu
end

CPUSelect -> SchedCore: target_cpu
deactivate CPUSelect

SchedCore -> SchedClass: enqueue_task()
activate SchedClass

alt CFS调度器
    SchedClass -> RunQueue: enqueue_entity()
    RunQueue -> RunQueue: update_vruntime()
    RunQueue -> RunQueue: rb_tree_insert()
    note right: 插入红黑树
else RT调度器
    SchedClass -> RunQueue: enqueue_rt_entity()
    RunQueue -> RunQueue: priority_queue_insert()
    note right: 按优先级插入
else Deadline调度器
    SchedClass -> RunQueue: enqueue_dl_entity()
    RunQueue -> RunQueue: deadline_rb_insert()
    note right: 按截止时间插入
end

SchedClass -> SchedCore: task_enqueued
deactivate SchedClass

SchedCore -> SchedCore: check_preempt_curr()
note right: 检查是否需要抢占当前任务

alt 需要抢占
    SchedCore -> SchedCore: resched_curr()
    note right: 设置重新调度标志
end

SchedCore -> Syscall: success
deactivate SchedCore

Syscall -> User: child_pid
deactivate Syscall

== 硬件中断触发的调度 ==

HardIRQ -> HardIRQ: 硬件中断发生
activate HardIRQ
note right: 时钟、网卡、磁盘等中断

HardIRQ -> HardIRQ: save_context()
note right: 保存被中断进程的上下文

alt 时钟中断处理
    HardIRQ -> SchedCore: scheduler_tick()
    activate SchedCore
    
    SchedCore -> SchedClass: task_tick()
    activate SchedClass
    
    alt CFS调度器
        SchedClass -> SchedClass: entity_tick()
        SchedClass -> SchedClass: check_preempt_tick()
        note right: 检查时间片是否用尽
    else RT调度器
        SchedClass -> SchedClass: task_tick_rt()
        note right: RR策略时间片轮转
    end
    
    alt 需要重新调度
        SchedClass -> SchedCore: need_resched = true
    end
    
    SchedClass -> SchedCore: tick_done
    deactivate SchedClass
    
    alt 需要负载均衡
        SchedCore -> SoftIRQ: raise_softirq(SCHED_SOFTIRQ)
        note right: 触发调度软中断
    end
    
    SchedCore -> HardIRQ: tick_processing_done
    deactivate SchedCore

else 网络中断处理
    HardIRQ -> HardIRQ: ack_interrupt()
    HardIRQ -> HardIRQ: minimal_processing()
    HardIRQ -> SoftIRQ: raise_softirq(NET_RX_SOFTIRQ)
    note right: 标记网络软中断

else 磁盘中断处理
    HardIRQ -> HardIRQ: ack_interrupt()
    HardIRQ -> HardIRQ: read_status()
    HardIRQ -> SoftIRQ: raise_softirq(BLOCK_SOFTIRQ)
    note right: 标记块设备软中断
end

HardIRQ -> HardIRQ: restore_context()
deactivate HardIRQ

== 软中断处理与调度 ==

HardIRQ -> SoftIRQ: irq_exit()
activate SoftIRQ

SoftIRQ -> SoftIRQ: __do_softirq()
note right: 处理待处理的软中断

alt SCHED_SOFTIRQ处理
    SoftIRQ -> LoadBalance: run_rebalance_domains()
    activate LoadBalance
    
    LoadBalance -> LoadBalance: rebalance_domains()
    note right: 在调度域间进行负载均衡
    
    alt 发现负载不均衡
        LoadBalance -> LoadBalance: load_balance()
        LoadBalance -> RunQueue: detach_tasks()
        note right: 从繁忙CPU分离任务
        LoadBalance -> RunQueue: attach_tasks()
        note right: 迁移到空闲CPU
    end
    
    LoadBalance -> SoftIRQ: balance_done
    deactivate LoadBalance

else NET_RX_SOFTIRQ处理
    SoftIRQ -> SoftIRQ: net_rx_action()
    note right: 网络数据包处理

else BLOCK_SOFTIRQ处理
    SoftIRQ -> SoftIRQ: blk_done_softirq()
    note right: 块设备I/O完成处理
    
    alt I/O操作完成
        SoftIRQ -> SchedCore: wake_up_process()
        note right: 唤醒等待I/O的进程
    end
end

SoftIRQ -> SchedCore: check_need_resched()
alt 需要调度
    SoftIRQ -> SchedCore: schedule()
    note right: 触发进程调度
end

deactivate SoftIRQ

== 信号处理与调度 ==

Signal -> Signal: 信号产生
activate Signal

Signal -> Signal: send_signal()
note right: 发送信号给目标进程

alt 目标进程状态检查
    alt TASK_INTERRUPTIBLE
        Signal -> SchedCore: wake_up_process()
        activate SchedCore
        SchedCore -> RunQueue: enqueue_task()
        SchedCore -> SchedCore: set_task_running()
        deactivate SchedCore
        
    else TASK_UNINTERRUPTIBLE
        alt 致命信号(SIGKILL)
            Signal -> SchedCore: force_wake_up()
            activate SchedCore
            SchedCore -> RunQueue: enqueue_task()
            deactivate SchedCore
        else 普通信号
            Signal -> Signal: 信号被忽略
            note right: 不可中断睡眠不响应普通信号
        end
    end
end

deactivate Signal

== 主动调度 (schedule) ==

User -> Syscall: sleep()/wait()/yield()
activate Syscall

Syscall -> SchedCore: schedule()
activate SchedCore

SchedCore -> SchedCore: __schedule()

SchedCore -> Signal: signal_pending_state()
activate Signal
alt 有待处理信号且进程可中断
    Signal -> SchedCore: 设置TASK_RUNNING
else 无信号或不可中断
    Signal -> SchedCore: 继续调度流程
end
deactivate Signal

SchedCore -> SchedClass: put_prev_task()
activate SchedClass
SchedClass -> RunQueue: put_prev_entity()
note right: 保存当前任务状态
SchedClass -> SchedCore: prev_saved
deactivate SchedClass

SchedCore -> SchedCore: pick_next_task()

loop 按优先级检查调度器类
    SchedCore -> SchedClass: pick_next_task()
    activate SchedClass
    
    alt Stop调度器
        SchedClass -> RunQueue: pick_next_stop()
        note right: 最高优先级
    else Deadline调度器  
        SchedClass -> RunQueue: pick_earliest_deadline()
        note right: 最早截止时间
    else RT调度器
        SchedClass -> RunQueue: pick_highest_priority()
        note right: 最高静态优先级
    else CFS调度器
        SchedClass -> RunQueue: pick_leftmost_entity()
        note right: vruntime最小的任务
    else Idle调度器
        SchedClass -> RunQueue: pick_idle_task()
        note right: 空闲任务
    end
    
    alt 找到可运行任务
        SchedClass -> SchedCore: next_task
        deactivate SchedClass
    else 继续下一个调度器类
        SchedClass -> SchedCore: NULL
        deactivate SchedClass
    end
end

alt next_task != prev_task
    SchedCore -> Context: context_switch()
    activate Context
    
    Context -> Context: switch_mm()
    note right: 切换内存映射
    
    Context -> Context: switch_to()
    note right: 切换寄存器状态
    
    Context -> SchedCore: switch_done
    deactivate Context
end

SchedCore -> SchedClass: set_next_task()
activate SchedClass
SchedClass -> RunQueue: update_curr()
note right: 更新当前任务统计
SchedClass -> SchedCore: task_set
deactivate SchedClass

SchedCore -> Syscall: schedule_done
deactivate SchedCore

Syscall -> User: return
deactivate Syscall

== 中断上下文调度限制 ==

note over HardIRQ, SoftIRQ
    调度限制：
    1. 硬中断上下文：禁止调度，只能标记need_resched
    2. 软中断上下文：禁止调度，延迟到irq_exit()后处理
    3. 进程上下文：允许正常调度
    4. 中断退出时检查并执行延迟的调度
end note

== CPU绑定和迁移 ==

User -> Syscall: sched_setaffinity()
activate Syscall

Syscall -> SchedCore: __sched_setaffinity()
activate SchedCore

SchedCore -> SchedCore: check_cpumask_valid()
note right: 验证CPU掩码有效性

alt 当前CPU不在新掩码中
    SchedCore -> LoadBalance: migrate_task()
    activate LoadBalance
    
    LoadBalance -> CPUSelect: select_target_cpu()
    activate CPUSelect
    
    CPUSelect -> CPUSelect: cpumask_intersects()
    note right: 检查亲和性掩码
    
    CPUSelect -> LoadBalance: target_cpu
    deactivate CPUSelect
    
    LoadBalance -> RunQueue: deactivate_task()
    note right: 从当前CPU移除
    
    LoadBalance -> RunQueue: set_task_cpu()
    note right: 设置新CPU
    
    LoadBalance -> RunQueue: activate_task()
    note right: 添加到目标CPU
    
    LoadBalance -> SchedCore: migration_done
    deactivate LoadBalance
end

SchedCore -> Syscall: affinity_set
deactivate SchedCore

Syscall -> User: success
deactivate Syscall

== 实时任务调度 ==

User -> Syscall: sched_setscheduler(SCHED_FIFO)
activate Syscall

Syscall -> SchedCore: __sched_setscheduler()
activate SchedCore

SchedCore -> SchedCore: check_rt_bandwidth()
note right: 检查RT带宽限制

SchedCore -> SchedClass: switched_to_rt()
activate SchedClass

SchedClass -> RunQueue: enqueue_rt_entity()
note right: 按优先级插入RT队列

SchedClass -> SchedClass: check_preempt_curr_rt()
note right: 检查是否抢占当前任务

alt RT任务优先级更高
    SchedClass -> SchedCore: resched_curr()
    note right: 立即重新调度
end

SchedClass -> SchedCore: rt_task_scheduled
deactivate SchedClass

SchedCore -> Syscall: policy_changed
deactivate SchedCore

Syscall -> User: success
deactivate Syscall

== NUMA感知调度 ==

Interrupt -> SchedCore: numa_balancing_tick()
activate Interrupt
activate SchedCore

SchedCore -> SchedCore: task_numa_fault()
note right: 记录NUMA页面错误

SchedCore -> SchedCore: task_numa_placement()
note right: 分析NUMA访问模式

alt 发现更好的NUMA节点
    SchedCore -> LoadBalance: task_numa_migrate()
    activate LoadBalance
    
    LoadBalance -> CPUSelect: find_best_numa_cpu()
    activate CPUSelect
    
    CPUSelect -> CPUSelect: evaluate_numa_nodes()
    note right: 评估所有NUMA节点
    
    CPUSelect -> LoadBalance: best_numa_cpu
    deactivate CPUSelect
    
    LoadBalance -> RunQueue: migrate_to_numa_node()
    note right: 迁移到最佳NUMA节点
    
    LoadBalance -> SchedCore: numa_migration_done
    deactivate LoadBalance
end

SchedCore -> Interrupt: numa_balance_done
deactivate SchedCore
deactivate Interrupt

== 唤醒路径 ==

User -> Syscall: signal/wakeup()
activate Syscall

Syscall -> SchedCore: try_to_wake_up()
activate SchedCore

SchedCore -> SchedCore: task_state_check()
note right: 检查任务状态

alt 任务在睡眠状态
    SchedCore -> CPUSelect: select_task_rq_fair()
    activate CPUSelect
    
    CPUSelect -> CPUSelect: want_affine_check()
    note right: 检查唤醒亲和性
    
    alt 使用唤醒亲和性
        CPUSelect -> CPUSelect: wake_affine()
        note right: 选择亲和CPU
    else 查找最空闲CPU
        CPUSelect -> CPUSelect: find_idlest_group()
        CPUSelect -> CPUSelect: find_idlest_cpu()
    end
    
    CPUSelect -> SchedCore: target_cpu
    deactivate CPUSelect
    
    SchedCore -> SchedClass: enqueue_task()
    activate SchedClass
    SchedClass -> RunQueue: enqueue_entity()
    SchedClass -> SchedCore: task_enqueued
    deactivate SchedClass
    
    SchedCore -> SchedCore: check_preempt_curr()
    
    alt 需要抢占
        SchedCore -> SchedCore: resched_curr()
    end
end

SchedCore -> Syscall: wakeup_done
deactivate SchedCore

Syscall -> User: success
deactivate Syscall

@enduml 