# æ–‡ä»¶å’Œç›®å½•æ“ä½œ

## å­¦ä¹ ç›®æ ‡
- æŒæ¡osåŒ…çš„æ–‡ä»¶ç³»ç»Ÿæ“ä½œ
- å­¦ä¹ ioåŒ…çš„è¾“å…¥è¾“å‡ºæ¥å£
- ç†è§£bufioåŒ…çš„ç¼“å†²æ“ä½œ
- æŒæ¡filepathåŒ…çš„è·¯å¾„å¤„ç†

## 1. osåŒ… - åŸºç¡€æ–‡ä»¶æ“ä½œ

### æ–‡ä»¶çš„åˆ›å»ºã€æ‰“å¼€å’Œå…³é—­
```go
import (
    "fmt"
    "os"
    "io"
)

func basicFileOperations() {
    // åˆ›å»ºæ–‡ä»¶
    file, err := os.Create("example.txt")
    if err != nil {
        fmt.Printf("åˆ›å»ºæ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer file.Close()
    
    // å†™å…¥å†…å®¹
    content := "Hello, Go file operations!"
    if _, err := file.WriteString(content); err != nil {
        fmt.Printf("å†™å…¥æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Println("æ–‡ä»¶åˆ›å»ºå¹¶å†™å…¥æˆåŠŸ")
    
    // æ‰“å¼€æ–‡ä»¶ï¼ˆåªè¯»ï¼‰
    readFile, err := os.Open("example.txt")
    if err != nil {
        fmt.Printf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer readFile.Close()
    
    // è¯»å–æ–‡ä»¶å†…å®¹
    buffer := make([]byte, 1024)
    n, err := readFile.Read(buffer)
    if err != nil && err != io.EOF {
        fmt.Printf("è¯»å–æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Printf("è¯»å–åˆ° %d å­—èŠ‚: %s\n", n, string(buffer[:n]))
    
    // ä»¥è¯»å†™æ¨¡å¼æ‰“å¼€æ–‡ä»¶
    rwFile, err := os.OpenFile("example.txt", os.O_RDWR|os.O_APPEND, 0644)
    if err != nil {
        fmt.Printf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer rwFile.Close()
    
    // è¿½åŠ å†…å®¹
    if _, err := rwFile.WriteString("\nè¿½åŠ çš„å†…å®¹"); err != nil {
        fmt.Printf("è¿½åŠ å†…å®¹å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Println("å†…å®¹è¿½åŠ æˆåŠŸ")
}
```

### æ–‡ä»¶æƒé™å’Œå±æ€§
```go
func filePermissionsAndAttributes() {
    filename := "test_permissions.txt"
    
    // åˆ›å»ºæ–‡ä»¶å¹¶è®¾ç½®æƒé™
    file, err := os.OpenFile(filename, os.O_CREATE|os.O_WRONLY, 0755)
    if err != nil {
        fmt.Printf("åˆ›å»ºæ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    file.Close()
    
    // è·å–æ–‡ä»¶ä¿¡æ¯
    info, err := os.Stat(filename)
    if err != nil {
        fmt.Printf("è·å–æ–‡ä»¶ä¿¡æ¯å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Printf("æ–‡ä»¶å: %s\n", info.Name())
    fmt.Printf("å¤§å°: %d bytes\n", info.Size())
    fmt.Printf("æƒé™: %s\n", info.Mode())
    fmt.Printf("ä¿®æ”¹æ—¶é—´: %v\n", info.ModTime())
    fmt.Printf("æ˜¯å¦ä¸ºç›®å½•: %v\n", info.IsDir())
    
    // ä¿®æ”¹æ–‡ä»¶æƒé™
    if err := os.Chmod(filename, 0644); err != nil {
        fmt.Printf("ä¿®æ”¹æƒé™å¤±è´¥: %v\n", err)
    } else {
        fmt.Println("æ–‡ä»¶æƒé™ä¿®æ”¹æˆåŠŸ")
    }
    
    // é‡å‘½åæ–‡ä»¶
    newName := "renamed_file.txt"
    if err := os.Rename(filename, newName); err != nil {
        fmt.Printf("é‡å‘½åå¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("æ–‡ä»¶å·²é‡å‘½åä¸º: %s\n", newName)
    }
    
    // åˆ é™¤æ–‡ä»¶
    if err := os.Remove(newName); err != nil {
        fmt.Printf("åˆ é™¤æ–‡ä»¶å¤±è´¥: %v\n", err)
    } else {
        fmt.Println("æ–‡ä»¶åˆ é™¤æˆåŠŸ")
    }
}
```

### ç›®å½•æ“ä½œ
```go
func directoryOperations() {
    // åˆ›å»ºç›®å½•
    dirName := "test_directory"
    if err := os.Mkdir(dirName, 0755); err != nil {
        fmt.Printf("åˆ›å»ºç›®å½•å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("ç›®å½• %s åˆ›å»ºæˆåŠŸ\n", dirName)
    }
    
    // åˆ›å»ºå¤šçº§ç›®å½•
    nestedDir := "parent/child/grandchild"
    if err := os.MkdirAll(nestedDir, 0755); err != nil {
        fmt.Printf("åˆ›å»ºå¤šçº§ç›®å½•å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("å¤šçº§ç›®å½• %s åˆ›å»ºæˆåŠŸ\n", nestedDir)
    }
    
    // è¯»å–ç›®å½•å†…å®¹
    entries, err := os.ReadDir(".")
    if err != nil {
        fmt.Printf("è¯»å–ç›®å½•å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Println("å½“å‰ç›®å½•å†…å®¹:")
    for _, entry := range entries {
        info, _ := entry.Info()
        fmt.Printf("  %s (%s, %d bytes)\n", 
                   entry.Name(), 
                   info.Mode(), 
                   info.Size())
    }
    
    // è·å–å½“å‰å·¥ä½œç›®å½•
    if wd, err := os.Getwd(); err == nil {
        fmt.Printf("å½“å‰å·¥ä½œç›®å½•: %s\n", wd)
    }
    
    // åˆ‡æ¢ç›®å½•
    if err := os.Chdir(dirName); err != nil {
        fmt.Printf("åˆ‡æ¢ç›®å½•å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("å·²åˆ‡æ¢åˆ°ç›®å½•: %s\n", dirName)
        
        // åˆ‡æ¢å›åŸç›®å½•
        os.Chdir("..")
    }
    
    // åˆ é™¤ç›®å½•
    if err := os.Remove(dirName); err != nil {
        fmt.Printf("åˆ é™¤ç›®å½•å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("ç›®å½• %s åˆ é™¤æˆåŠŸ\n", dirName)
    }
    
    // é€’å½’åˆ é™¤ç›®å½•
    if err := os.RemoveAll("parent"); err != nil {
        fmt.Printf("é€’å½’åˆ é™¤ç›®å½•å¤±è´¥: %v\n", err)
    } else {
        fmt.Println("å¤šçº§ç›®å½•åˆ é™¤æˆåŠŸ")
    }
}
```

### æ–‡ä»¶å¤åˆ¶å’Œç§»åŠ¨
```go
func fileCopyAndMove() {
    // åˆ›å»ºæºæ–‡ä»¶
    sourceFile := "source.txt"
    content := "è¿™æ˜¯è¦å¤åˆ¶çš„æ–‡ä»¶å†…å®¹\nåŒ…å«å¤šè¡Œæ–‡æœ¬\nç”¨äºæµ‹è¯•æ–‡ä»¶æ“ä½œ"
    
    if err := os.WriteFile(sourceFile, []byte(content), 0644); err != nil {
        fmt.Printf("åˆ›å»ºæºæ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    
    // å¤åˆ¶æ–‡ä»¶
    copyFile := func(src, dst string) error {
        sourceFile, err := os.Open(src)
        if err != nil {
            return err
        }
        defer sourceFile.Close()
        
        destFile, err := os.Create(dst)
        if err != nil {
            return err
        }
        defer destFile.Close()
        
        _, err = io.Copy(destFile, sourceFile)
        return err
    }
    
    destFile := "destination.txt"
    if err := copyFile(sourceFile, destFile); err != nil {
        fmt.Printf("å¤åˆ¶æ–‡ä»¶å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("æ–‡ä»¶ä» %s å¤åˆ¶åˆ° %s\n", sourceFile, destFile)
    }
    
    // éªŒè¯å¤åˆ¶ç»“æœ
    if srcInfo, err := os.Stat(sourceFile); err == nil {
        if dstInfo, err := os.Stat(destFile); err == nil {
            fmt.Printf("æºæ–‡ä»¶å¤§å°: %d bytes\n", srcInfo.Size())
            fmt.Printf("ç›®æ ‡æ–‡ä»¶å¤§å°: %d bytes\n", dstInfo.Size())
            fmt.Printf("å¤åˆ¶æˆåŠŸ: %v\n", srcInfo.Size() == dstInfo.Size())
        }
    }
    
    // ç§»åŠ¨æ–‡ä»¶ï¼ˆé‡å‘½åï¼‰
    movedFile := "moved.txt"
    if err := os.Rename(destFile, movedFile); err != nil {
        fmt.Printf("ç§»åŠ¨æ–‡ä»¶å¤±è´¥: %v\n", err)
    } else {
        fmt.Printf("æ–‡ä»¶ç§»åŠ¨åˆ°: %s\n", movedFile)
    }
    
    // æ¸…ç†æ–‡ä»¶
    os.Remove(sourceFile)
    os.Remove(movedFile)
}
```

## 2. ioåŒ… - è¾“å…¥è¾“å‡ºæ¥å£

### åŸºæœ¬è¯»å†™æ¥å£
```go
func ioInterfaces() {
    // ä½¿ç”¨strings.Readerä½œä¸ºio.Reader
    reader := strings.NewReader("Hello, io interfaces!")
    
    // è¯»å–æ•°æ®
    buffer := make([]byte, 5)
    for {
        n, err := reader.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            fmt.Printf("è¯»å–é”™è¯¯: %v\n", err)
            break
        }
        fmt.Printf("è¯»å– %d å­—èŠ‚: %s\n", n, string(buffer[:n]))
    }
    
    // ä½¿ç”¨bytes.Bufferä½œä¸ºio.Writer
    var buffer2 bytes.Buffer
    
    data := []string{"Hello", " ", "io", " ", "interfaces", "!"}
    for _, s := range data {
        n, err := buffer2.WriteString(s)
        if err != nil {
            fmt.Printf("å†™å…¥é”™è¯¯: %v\n", err)
            break
        }
        fmt.Printf("å†™å…¥ %d å­—èŠ‚\n", n)
    }
    
    fmt.Printf("ç¼“å†²åŒºå†…å®¹: %s\n", buffer2.String())
}
```

### æ–‡ä»¶è¯»å†™æ“ä½œ
```go
func fileReadWrite() {
    filename := "io_test.txt"
    
    // å†™å…¥æ–‡ä»¶
    writeData := []byte("ç¬¬ä¸€è¡Œå†…å®¹\nç¬¬äºŒè¡Œå†…å®¹\nç¬¬ä¸‰è¡Œå†…å®¹\n")
    if err := os.WriteFile(filename, writeData, 0644); err != nil {
        fmt.Printf("å†™å…¥æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    
    // è¯»å–æ•´ä¸ªæ–‡ä»¶
    data, err := os.ReadFile(filename)
    if err != nil {
        fmt.Printf("è¯»å–æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    fmt.Printf("æ–‡ä»¶å†…å®¹:\n%s", string(data))
    
    // é€è¡Œè¯»å–
    file, err := os.Open(filename)
    if err != nil {
        fmt.Printf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer file.Close()
    
    scanner := bufio.NewScanner(file)
    lineNum := 1
    fmt.Println("é€è¡Œè¯»å–:")
    for scanner.Scan() {
        fmt.Printf("ç¬¬%dè¡Œ: %s\n", lineNum, scanner.Text())
        lineNum++
    }
    
    if err := scanner.Err(); err != nil {
        fmt.Printf("æ‰«æé”™è¯¯: %v\n", err)
    }
    
    // æ¸…ç†
    os.Remove(filename)
}
```

### æµæ“ä½œå’Œç®¡é“
```go
func streamOperations() {
    // åˆ›å»ºç®¡é“
    reader, writer := io.Pipe()
    
    // å†™å…¥æ•°æ®ï¼ˆåœ¨goroutineä¸­ï¼‰
    go func() {
        defer writer.Close()
        for i := 1; i <= 5; i++ {
            data := fmt.Sprintf("æ•°æ®å— %d\n", i)
            writer.Write([]byte(data))
            time.Sleep(100 * time.Millisecond)
        }
    }()
    
    // è¯»å–æ•°æ®
    buffer := make([]byte, 1024)
    for {
        n, err := reader.Read(buffer)
        if err == io.EOF {
            break
        }
        if err != nil {
            fmt.Printf("è¯»å–é”™è¯¯: %v\n", err)
            break
        }
        fmt.Printf("æ¥æ”¶: %s", string(buffer[:n]))
    }
    
    reader.Close()
}
```

### å¤šé‡å†™å…¥å™¨å’Œè¯»å–å™¨
```go
func multiWriterReader() {
    // åˆ›å»ºå¤šä¸ªå†™å…¥ç›®æ ‡
    var buf1, buf2 bytes.Buffer
    file, _ := os.Create("multi_output.txt")
    defer file.Close()
    defer os.Remove("multi_output.txt")
    
    // åˆ›å»ºå¤šé‡å†™å…¥å™¨
    multiWriter := io.MultiWriter(&buf1, &buf2, file, os.Stdout)
    
    // å†™å…¥æ•°æ®ä¼šåŒæ—¶å†™åˆ°æ‰€æœ‰ç›®æ ‡
    data := "è¿™æ®µæ–‡æœ¬ä¼šå†™å…¥å¤šä¸ªç›®æ ‡\n"
    multiWriter.Write([]byte(data))
    
    fmt.Printf("ç¼“å†²åŒº1: %s", buf1.String())
    fmt.Printf("ç¼“å†²åŒº2: %s", buf2.String())
    
    // å¤šé‡è¯»å–å™¨
    readers := []io.Reader{
        strings.NewReader("ç¬¬ä¸€ä¸ªè¯»å–å™¨çš„å†…å®¹\n"),
        strings.NewReader("ç¬¬äºŒä¸ªè¯»å–å™¨çš„å†…å®¹\n"),
        strings.NewReader("ç¬¬ä¸‰ä¸ªè¯»å–å™¨çš„å†…å®¹\n"),
    }
    
    multiReader := io.MultiReader(readers...)
    
    // ä»å¤šé‡è¯»å–å™¨è¯»å–æ•°æ®
    output, err := io.ReadAll(multiReader)
    if err != nil {
        fmt.Printf("è¯»å–é”™è¯¯: %v\n", err)
        return
    }
    
    fmt.Printf("å¤šé‡è¯»å–å™¨è¾“å‡º:\n%s", string(output))
}
```

## 3. bufioåŒ… - ç¼“å†²æ“ä½œ

### ç¼“å†²è¯»å–
```go
func bufferedReading() {
    filename := "buffered_test.txt"
    content := `ç¬¬ä¸€è¡Œæ–‡æœ¬
ç¬¬äºŒè¡Œæ–‡æœ¬
ç¬¬ä¸‰è¡Œæ–‡æœ¬
åŒ…å«æ•°å­—: 123 456 789
åŒ…å«ç‰¹æ®Šå­—ç¬¦: !@#$%^&*()`
    
    // åˆ›å»ºæµ‹è¯•æ–‡ä»¶
    os.WriteFile(filename, []byte(content), 0644)
    defer os.Remove(filename)
    
    file, err := os.Open(filename)
    if err != nil {
        fmt.Printf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer file.Close()
    
    // åˆ›å»ºç¼“å†²è¯»å–å™¨
    reader := bufio.NewReader(file)
    
    fmt.Println("é€è¡Œè¯»å–:")
    lineNum := 1
    for {
        line, err := reader.ReadLine()
        if err == io.EOF {
            break
        }
        if err != nil {
            fmt.Printf("è¯»å–é”™è¯¯: %v\n", err)
            break
        }
        fmt.Printf("ç¬¬%dè¡Œ: %s\n", lineNum, string(line))
        lineNum++
    }
    
    // é‡æ–°æ‰“å¼€æ–‡ä»¶è¿›è¡Œå…¶ä»–è¯»å–æ“ä½œ
    file.Seek(0, 0)
    reader.Reset(file)
    
    fmt.Println("\næŒ‰åˆ†éš”ç¬¦è¯»å–:")
    for {
        token, err := reader.ReadString('\n')
        if err == io.EOF {
            if len(token) > 0 {
                fmt.Printf("æœ€åä¸€æ®µ: %s", token)
            }
            break
        }
        if err != nil {
            fmt.Printf("è¯»å–é”™è¯¯: %v\n", err)
            break
        }
        fmt.Printf("è¯»å–åˆ°: %s", token)
    }
}
```

### ç¼“å†²å†™å…¥
```go
func bufferedWriting() {
    filename := "buffered_write.txt"
    
    file, err := os.Create(filename)
    if err != nil {
        fmt.Printf("åˆ›å»ºæ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer file.Close()
    defer os.Remove(filename)
    
    // åˆ›å»ºç¼“å†²å†™å…¥å™¨
    writer := bufio.NewWriter(file)
    
    // å†™å…¥æ•°æ®
    lines := []string{
        "ç¼“å†²å†™å…¥ç¬¬ä¸€è¡Œ\n",
        "ç¼“å†²å†™å…¥ç¬¬äºŒè¡Œ\n",
        "ç¼“å†²å†™å…¥ç¬¬ä¸‰è¡Œ\n",
    }
    
    for i, line := range lines {
        n, err := writer.WriteString(line)
        if err != nil {
            fmt.Printf("å†™å…¥é”™è¯¯: %v\n", err)
            return
        }
        fmt.Printf("å†™å…¥ç¬¬%dè¡Œï¼Œ%då­—èŠ‚\n", i+1, n)
    }
    
    // åˆ·æ–°ç¼“å†²åŒº
    if err := writer.Flush(); err != nil {
        fmt.Printf("åˆ·æ–°ç¼“å†²åŒºå¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Println("æ•°æ®å·²åˆ·æ–°åˆ°æ–‡ä»¶")
    
    // éªŒè¯å†™å…¥ç»“æœ
    data, _ := os.ReadFile(filename)
    fmt.Printf("æ–‡ä»¶å†…å®¹:\n%s", string(data))
}
```

### Scannerä½¿ç”¨
```go
func scannerUsage() {
    // ä»æ ‡å‡†è¾“å…¥è¯»å–ï¼ˆæ¨¡æ‹Ÿï¼‰
    input := "apple banana cherry\ndog elephant fox\n123 456 789"
    reader := strings.NewReader(input)
    scanner := bufio.NewScanner(reader)
    
    // é»˜è®¤æŒ‰è¡Œæ‰«æ
    fmt.Println("æŒ‰è¡Œæ‰«æ:")
    lineNum := 1
    for scanner.Scan() {
        fmt.Printf("ç¬¬%dè¡Œ: %s\n", lineNum, scanner.Text())
        lineNum++
    }
    
    if err := scanner.Err(); err != nil {
        fmt.Printf("æ‰«æé”™è¯¯: %v\n", err)
    }
    
    // æŒ‰å•è¯æ‰«æ
    reader2 := strings.NewReader(input)
    scanner2 := bufio.NewScanner(reader2)
    scanner2.Split(bufio.ScanWords)
    
    fmt.Println("\næŒ‰å•è¯æ‰«æ:")
    wordNum := 1
    for scanner2.Scan() {
        fmt.Printf("ç¬¬%dä¸ªå•è¯: %s\n", wordNum, scanner2.Text())
        wordNum++
    }
    
    // è‡ªå®šä¹‰åˆ†å‰²å‡½æ•°
    reader3 := strings.NewReader("data1,data2,data3,data4")
    scanner3 := bufio.NewScanner(reader3)
    
    // æŒ‰é€—å·åˆ†å‰²
    scanner3.Split(func(data []byte, atEOF bool) (advance int, token []byte, err error) {
        for i := 0; i < len(data); i++ {
            if data[i] == ',' {
                return i + 1, data[:i], nil
            }
        }
        if atEOF && len(data) > 0 {
            return len(data), data, nil
        }
        return 0, nil, nil
    })
    
    fmt.Println("\næŒ‰é€—å·åˆ†å‰²:")
    for scanner3.Scan() {
        fmt.Printf("æ•°æ®: %s\n", scanner3.Text())
    }
}
```

## 4. filepathåŒ… - è·¯å¾„å¤„ç†

### è·¯å¾„æ“ä½œ
```go
import "path/filepath"

func pathOperations() {
    // è·¯å¾„è¿æ¥
    path1 := filepath.Join("home", "user", "documents", "file.txt")
    fmt.Printf("è¿æ¥è·¯å¾„: %s\n", path1)
    
    // å¹³å°ç‰¹å®šçš„è·¯å¾„åˆ†éš”ç¬¦
    fmt.Printf("è·¯å¾„åˆ†éš”ç¬¦: %c\n", filepath.Separator)
    fmt.Printf("åˆ—è¡¨åˆ†éš”ç¬¦: %c\n", filepath.ListSeparator)
    
    // è·¯å¾„åˆ†è§£
    dir := filepath.Dir(path1)
    base := filepath.Base(path1)
    ext := filepath.Ext(path1)
    
    fmt.Printf("ç›®å½•: %s\n", dir)
    fmt.Printf("æ–‡ä»¶å: %s\n", base)
    fmt.Printf("æ‰©å±•å: %s\n", ext)
    
    // è·å–ä¸å¸¦æ‰©å±•åçš„æ–‡ä»¶å
    nameWithoutExt := base[:len(base)-len(ext)]
    fmt.Printf("ä¸å¸¦æ‰©å±•åçš„æ–‡ä»¶å: %s\n", nameWithoutExt)
    
    // è·¯å¾„æ¸…ç†
    messyPath := "home//user/../user/./documents//file.txt"
    cleanPath := filepath.Clean(messyPath)
    fmt.Printf("æ¸…ç†å‰: %s\n", messyPath)
    fmt.Printf("æ¸…ç†å: %s\n", cleanPath)
    
    // ç›¸å¯¹è·¯å¾„è½¬ç»å¯¹è·¯å¾„
    if absPath, err := filepath.Abs("file.txt"); err == nil {
        fmt.Printf("ç»å¯¹è·¯å¾„: %s\n", absPath)
    }
    
    // è®¡ç®—ç›¸å¯¹è·¯å¾„
    if relPath, err := filepath.Rel("/home/user", "/home/user/documents/file.txt"); err == nil {
        fmt.Printf("ç›¸å¯¹è·¯å¾„: %s\n", relPath)
    }
}
```

### è·¯å¾„åŒ¹é…å’Œæœç´¢
```go
func pathMatching() {
    // åˆ›å»ºæµ‹è¯•æ–‡ä»¶ç»“æ„
    testFiles := []string{
        "test/file1.txt",
        "test/file2.log",
        "test/subdir/file3.txt",
        "test/subdir/file4.go",
        "test/another/file5.txt",
    }
    
    // åˆ›å»ºç›®å½•ç»“æ„
    for _, file := range testFiles {
        dir := filepath.Dir(file)
        os.MkdirAll(dir, 0755)
        
        f, _ := os.Create(file)
        f.WriteString("æµ‹è¯•å†…å®¹")
        f.Close()
    }
    
    // æ¸…ç†å‡½æ•°
    defer os.RemoveAll("test")
    
    // è·¯å¾„åŒ¹é…
    patterns := []string{
        "test/*.txt",
        "test/**/*.txt",
        "test/subdir/*",
        "test/**/*.go",
    }
    
    for _, pattern := range patterns {
        fmt.Printf("\næ¨¡å¼: %s\n", pattern)
        matches, err := filepath.Glob(pattern)
        if err != nil {
            fmt.Printf("åŒ¹é…é”™è¯¯: %v\n", err)
            continue
        }
        
        for _, match := range matches {
            fmt.Printf("  åŒ¹é…: %s\n", match)
        }
    }
    
    // éå†ç›®å½•æ ‘
    fmt.Println("\nç›®å½•æ ‘éå†:")
    err := filepath.Walk("test", func(path string, info os.FileInfo, err error) error {
        if err != nil {
            return err
        }
        
        indent := strings.Repeat("  ", strings.Count(path, string(filepath.Separator)))
        if info.IsDir() {
            fmt.Printf("%sğŸ“ %s/\n", indent, info.Name())
        } else {
            fmt.Printf("%sğŸ“„ %s (%d bytes)\n", indent, info.Name(), info.Size())
        }
        
        return nil
    })
    
    if err != nil {
        fmt.Printf("éå†é”™è¯¯: %v\n", err)
    }
}
```

### æ–‡ä»¶æŸ¥æ‰¾å’Œè¿‡æ»¤
```go
func fileSearchAndFilter() {
    // åˆ›å»ºæµ‹è¯•ç¯å¢ƒ
    testDir := "search_test"
    os.MkdirAll(testDir, 0755)
    defer os.RemoveAll(testDir)
    
    // åˆ›å»ºä¸åŒç±»å‹çš„æ–‡ä»¶
    files := map[string]string{
        "document.txt":    "æ–‡æ¡£å†…å®¹",
        "script.go":      "package main",
        "data.json":      `{"key": "value"}`,
        "image.png":      "PNGå›¾ç‰‡æ•°æ®",
        "readme.md":      "# README",
        "config.yaml":    "config: value",
        "backup.txt.bak": "å¤‡ä»½æ–‡ä»¶",
    }
    
    for filename, content := range files {
        filepath := filepath.Join(testDir, filename)
        os.WriteFile(filepath, []byte(content), 0644)
    }
    
    // æ–‡ä»¶æŸ¥æ‰¾å™¨
    type FileFilter struct {
        Extensions []string
        MinSize    int64
        MaxSize    int64
        Pattern    string
    }
    
    findFiles := func(dir string, filter FileFilter) ([]string, error) {
        var results []string
        
        err := filepath.Walk(dir, func(path string, info os.FileInfo, err error) error {
            if err != nil {
                return err
            }
            
            if info.IsDir() {
                return nil
            }
            
            // æ‰©å±•åè¿‡æ»¤
            if len(filter.Extensions) > 0 {
                ext := filepath.Ext(path)
                found := false
                for _, allowedExt := range filter.Extensions {
                    if ext == allowedExt {
                        found = true
                        break
                    }
                }
                if !found {
                    return nil
                }
            }
            
            // å¤§å°è¿‡æ»¤
            if filter.MinSize > 0 && info.Size() < filter.MinSize {
                return nil
            }
            if filter.MaxSize > 0 && info.Size() > filter.MaxSize {
                return nil
            }
            
            // æ¨¡å¼åŒ¹é…
            if filter.Pattern != "" {
                matched, err := filepath.Match(filter.Pattern, info.Name())
                if err != nil || !matched {
                    return nil
                }
            }
            
            results = append(results, path)
            return nil
        })
        
        return results, err
    }
    
    // æµ‹è¯•ä¸åŒçš„è¿‡æ»¤æ¡ä»¶
    filters := []FileFilter{
        {Extensions: []string{".txt", ".md"}},
        {Pattern: "*.go"},
        {MinSize: 10},
        {Extensions: []string{".json", ".yaml"}},
    }
    
    filterNames := []string{
        "æ–‡æœ¬æ–‡ä»¶",
        "Goæºç ",
        "å¤§äº10å­—èŠ‚",
        "é…ç½®æ–‡ä»¶",
    }
    
    for i, filter := range filters {
        fmt.Printf("\n%s:\n", filterNames[i])
        results, err := findFiles(testDir, filter)
        if err != nil {
            fmt.Printf("æœç´¢é”™è¯¯: %v\n", err)
            continue
        }
        
        for _, result := range results {
            info, _ := os.Stat(result)
            fmt.Printf("  %s (%d bytes)\n", result, info.Size())
        }
    }
}
```

## 5. é«˜çº§æ–‡ä»¶æ“ä½œ

### æ–‡ä»¶ç›‘æ§
```go
func fileWatcher() {
    // åˆ›å»ºæµ‹è¯•æ–‡ä»¶
    testFile := "watched_file.txt"
    os.WriteFile(testFile, []byte("åˆå§‹å†…å®¹"), 0644)
    defer os.Remove(testFile)
    
    // ç®€å•çš„æ–‡ä»¶å˜åŒ–æ£€æµ‹
    var lastModTime time.Time
    var lastSize int64
    
    checkFile := func() (bool, string) {
        info, err := os.Stat(testFile)
        if err != nil {
            return false, fmt.Sprintf("æ–‡ä»¶ä¸å­˜åœ¨: %v", err)
        }
        
        if info.ModTime() != lastModTime || info.Size() != lastSize {
            change := fmt.Sprintf("æ–‡ä»¶å˜åŒ– - å¤§å°: %d->%d, ä¿®æ”¹æ—¶é—´: %v", 
                                   lastSize, info.Size(), info.ModTime())
            lastModTime = info.ModTime()
            lastSize = info.Size()
            return true, change
        }
        
        return false, "æ— å˜åŒ–"
    }
    
    // åˆå§‹åŒ–
    info, _ := os.Stat(testFile)
    lastModTime = info.ModTime()
    lastSize = info.Size()
    
    fmt.Println("å¼€å§‹ç›‘æ§æ–‡ä»¶å˜åŒ–...")
    
    // æ¨¡æ‹Ÿæ–‡ä»¶å˜åŒ–
    go func() {
        time.Sleep(1 * time.Second)
        os.WriteFile(testFile, []byte("ä¿®æ”¹åçš„å†…å®¹"), 0644)
        
        time.Sleep(1 * time.Second)
        os.WriteFile(testFile, []byte("å†æ¬¡ä¿®æ”¹çš„å†…å®¹\nå¢åŠ äº†ä¸€è¡Œ"), 0644)
    }()
    
    // ç›‘æ§å¾ªç¯
    for i := 0; i < 5; i++ {
        if changed, msg := checkFile(); changed {
            fmt.Printf("æ£€æµ‹åˆ°å˜åŒ–: %s\n", msg)
        } else {
            fmt.Printf("æ£€æŸ¥ %d: %s\n", i+1, msg)
        }
        time.Sleep(500 * time.Millisecond)
    }
}
```

### ä¸´æ—¶æ–‡ä»¶å’Œç›®å½•
```go
func temporaryFilesAndDirs() {
    // åˆ›å»ºä¸´æ—¶æ–‡ä»¶
    tempFile, err := os.CreateTemp("", "example_*.txt")
    if err != nil {
        fmt.Printf("åˆ›å»ºä¸´æ—¶æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer os.Remove(tempFile.Name())
    defer tempFile.Close()
    
    fmt.Printf("ä¸´æ—¶æ–‡ä»¶: %s\n", tempFile.Name())
    
    // å†™å…¥ä¸´æ—¶æ–‡ä»¶
    content := "è¿™æ˜¯ä¸´æ—¶æ–‡ä»¶çš„å†…å®¹\nä¸´æ—¶æ–‡ä»¶ç”¨äºæµ‹è¯•"
    if _, err := tempFile.WriteString(content); err != nil {
        fmt.Printf("å†™å…¥ä¸´æ—¶æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    
    // åˆ›å»ºä¸´æ—¶ç›®å½•
    tempDir, err := os.MkdirTemp("", "example_dir_*")
    if err != nil {
        fmt.Printf("åˆ›å»ºä¸´æ—¶ç›®å½•å¤±è´¥: %v\n", err)
        return
    }
    defer os.RemoveAll(tempDir)
    
    fmt.Printf("ä¸´æ—¶ç›®å½•: %s\n", tempDir)
    
    // åœ¨ä¸´æ—¶ç›®å½•ä¸­åˆ›å»ºæ–‡ä»¶
    tempFilePath := filepath.Join(tempDir, "temp_file.txt")
    if err := os.WriteFile(tempFilePath, []byte("ä¸´æ—¶ç›®å½•ä¸­çš„æ–‡ä»¶"), 0644); err != nil {
        fmt.Printf("åœ¨ä¸´æ—¶ç›®å½•åˆ›å»ºæ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    
    // åˆ—å‡ºä¸´æ—¶ç›®å½•å†…å®¹
    entries, err := os.ReadDir(tempDir)
    if err != nil {
        fmt.Printf("è¯»å–ä¸´æ—¶ç›®å½•å¤±è´¥: %v\n", err)
        return
    }
    
    fmt.Println("ä¸´æ—¶ç›®å½•å†…å®¹:")
    for _, entry := range entries {
        fmt.Printf("  %s\n", entry.Name())
    }
}
```

### æ–‡ä»¶é”å®š
```go
func fileLocking() {
    filename := "locked_file.txt"
    content := "è¿™ä¸ªæ–‡ä»¶å°†è¢«é”å®š"
    
    // åˆ›å»ºæ–‡ä»¶
    if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
        fmt.Printf("åˆ›å»ºæ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer os.Remove(filename)
    
    // ä»¥ç‹¬å æ¨¡å¼æ‰“å¼€æ–‡ä»¶ï¼ˆæ¨¡æ‹Ÿé”å®šï¼‰
    file, err := os.OpenFile(filename, os.O_RDWR, 0644)
    if err != nil {
        fmt.Printf("æ‰“å¼€æ–‡ä»¶å¤±è´¥: %v\n", err)
        return
    }
    defer file.Close()
    
    fmt.Printf("æ–‡ä»¶ %s å·²é”å®š\n", filename)
    
    // å°è¯•åœ¨å¦ä¸€ä¸ªgoroutineä¸­è®¿é—®æ–‡ä»¶
    done := make(chan bool)
    go func() {
        defer func() { done <- true }()
        
        // å°è¯•å†™å…¥æ–‡ä»¶
        if testFile, err := os.OpenFile(filename, os.O_WRONLY|os.O_APPEND, 0644); err == nil {
            testFile.WriteString("\nè¿½åŠ çš„å†…å®¹")
            testFile.Close()
            fmt.Println("æˆåŠŸè¿½åŠ å†…å®¹")
        } else {
            fmt.Printf("æ— æ³•è®¿é—®é”å®šçš„æ–‡ä»¶: %v\n", err)
        }
    }()
    
    // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡Šæ”¾é”
    time.Sleep(1 * time.Second)
    fmt.Println("é‡Šæ”¾æ–‡ä»¶é”")
    file.Close()
    
    <-done
    
    // éªŒè¯æœ€ç»ˆå†…å®¹
    if finalContent, err := os.ReadFile(filename); err == nil {
        fmt.Printf("æœ€ç»ˆæ–‡ä»¶å†…å®¹:\n%s\n", string(finalContent))
    }
}
```

## 6. å®è·µåº”ç”¨

### æ–‡ä»¶ç®¡ç†å™¨
```go
type FileManager struct {
    baseDir string
}

func NewFileManager(baseDir string) (*FileManager, error) {
    // ç¡®ä¿åŸºç¡€ç›®å½•å­˜åœ¨
    if err := os.MkdirAll(baseDir, 0755); err != nil {
        return nil, fmt.Errorf("åˆ›å»ºåŸºç¡€ç›®å½•å¤±è´¥: %w", err)
    }
    
    return &FileManager{baseDir: baseDir}, nil
}

func (fm *FileManager) CreateFile(relativePath string, content []byte) error {
    fullPath := filepath.Join(fm.baseDir, relativePath)
    
    // ç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
    if err := os.MkdirAll(filepath.Dir(fullPath), 0755); err != nil {
        return fmt.Errorf("åˆ›å»ºçˆ¶ç›®å½•å¤±è´¥: %w", err)
    }
    
    return os.WriteFile(fullPath, content, 0644)
}

func (fm *FileManager) ReadFile(relativePath string) ([]byte, error) {
    fullPath := filepath.Join(fm.baseDir, relativePath)
    return os.ReadFile(fullPath)
}

func (fm *FileManager) DeleteFile(relativePath string) error {
    fullPath := filepath.Join(fm.baseDir, relativePath)
    return os.Remove(fullPath)
}

func (fm *FileManager) ListFiles(pattern string) ([]string, error) {
    searchPattern := filepath.Join(fm.baseDir, pattern)
    matches, err := filepath.Glob(searchPattern)
    if err != nil {
        return nil, err
    }
    
    // è½¬æ¢ä¸ºç›¸å¯¹è·¯å¾„
    var relativeMatches []string
    for _, match := range matches {
        if rel, err := filepath.Rel(fm.baseDir, match); err == nil {
            relativeMatches = append(relativeMatches, rel)
        }
    }
    
    return relativeMatches, nil
}

func (fm *FileManager) GetFileInfo(relativePath string) (os.FileInfo, error) {
    fullPath := filepath.Join(fm.baseDir, relativePath)
    return os.Stat(fullPath)
}

func (fm *FileManager) CopyFile(src, dst string) error {
    srcPath := filepath.Join(fm.baseDir, src)
    dstPath := filepath.Join(fm.baseDir, dst)
    
    // ç¡®ä¿ç›®æ ‡ç›®å½•å­˜åœ¨
    if err := os.MkdirAll(filepath.Dir(dstPath), 0755); err != nil {
        return fmt.Errorf("åˆ›å»ºç›®æ ‡ç›®å½•å¤±è´¥: %w", err)
    }
    
    srcFile, err := os.Open(srcPath)
    if err != nil {
        return err
    }
    defer srcFile.Close()
    
    dstFile, err := os.Create(dstPath)
    if err != nil {
        return err
    }
    defer dstFile.Close()
    
    _, err = io.Copy(dstFile, srcFile)
    return err
}

// ä½¿ç”¨ç¤ºä¾‹
func fileManagerExample() {
    fm, err := NewFileManager("test_manager")
    if err != nil {
        fmt.Printf("åˆ›å»ºæ–‡ä»¶ç®¡ç†å™¨å¤±è´¥: %v\n", err)
        return
    }
    defer os.RemoveAll("test_manager")
    
    // åˆ›å»ºæ–‡ä»¶
    files := map[string]string{
        "documents/readme.txt":    "è¿™æ˜¯readmeæ–‡ä»¶",
        "documents/guide.txt":     "è¿™æ˜¯æŒ‡å¯¼æ–‡ä»¶",
        "config/app.conf":         "é…ç½®æ–‡ä»¶å†…å®¹",
        "logs/app.log":           "æ—¥å¿—æ–‡ä»¶å†…å®¹",
    }
    
    for path, content := range files {
        if err := fm.CreateFile(path, []byte(content)); err != nil {
            fmt.Printf("åˆ›å»ºæ–‡ä»¶å¤±è´¥ %s: %v\n", path, err)
            continue
        }
        fmt.Printf("åˆ›å»ºæ–‡ä»¶: %s\n", path)
    }
    
    // åˆ—å‡ºæ–‡ä»¶
    if txtFiles, err := fm.ListFiles("**/*.txt"); err == nil {
        fmt.Println("æ–‡æœ¬æ–‡ä»¶:")
        for _, file := range txtFiles {
            fmt.Printf("  %s\n", file)
        }
    }
    
    // å¤åˆ¶æ–‡ä»¶
    if err := fm.CopyFile("documents/readme.txt", "backup/readme_backup.txt"); err != nil {
        fmt.Printf("å¤åˆ¶æ–‡ä»¶å¤±è´¥: %v\n", err)
    } else {
        fmt.Println("æ–‡ä»¶å¤åˆ¶æˆåŠŸ")
    }
    
    // è·å–æ–‡ä»¶ä¿¡æ¯
    if info, err := fm.GetFileInfo("documents/readme.txt"); err == nil {
        fmt.Printf("æ–‡ä»¶ä¿¡æ¯: %s, å¤§å°: %d bytes, ä¿®æ”¹æ—¶é—´: %v\n", 
                   info.Name(), info.Size(), info.ModTime())
    }
}
```

### æ—¥å¿—æ–‡ä»¶è½®è½¬
```go
type LogRotator struct {
    baseName   string
    maxSize    int64
    maxFiles   int
    currentFile *os.File
    currentSize int64
}

func NewLogRotator(baseName string, maxSize int64, maxFiles int) *LogRotator {
    return &LogRotator{
        baseName: baseName,
        maxSize:  maxSize,
        maxFiles: maxFiles,
    }
}

func (lr *LogRotator) Write(data []byte) (int, error) {
    if lr.currentFile == nil || lr.currentSize+int64(len(data)) > lr.maxSize {
        if err := lr.rotate(); err != nil {
            return 0, err
        }
    }
    
    n, err := lr.currentFile.Write(data)
    lr.currentSize += int64(n)
    return n, err
}

func (lr *LogRotator) rotate() error {
    // å…³é—­å½“å‰æ–‡ä»¶
    if lr.currentFile != nil {
        lr.currentFile.Close()
    }
    
    // è½®è½¬ç°æœ‰æ–‡ä»¶
    for i := lr.maxFiles - 1; i >= 1; i-- {
        oldName := fmt.Sprintf("%s.%d", lr.baseName, i)
        newName := fmt.Sprintf("%s.%d", lr.baseName, i+1)
        
        if i == lr.maxFiles-1 {
            os.Remove(newName) // åˆ é™¤æœ€è€çš„æ–‡ä»¶
        }
        
        if _, err := os.Stat(oldName); err == nil {
            os.Rename(oldName, newName)
        }
    }
    
    // è½®è½¬å½“å‰æ–‡ä»¶
    if _, err := os.Stat(lr.baseName); err == nil {
        os.Rename(lr.baseName, lr.baseName+".1")
    }
    
    // åˆ›å»ºæ–°æ–‡ä»¶
    var err error
    lr.currentFile, err = os.Create(lr.baseName)
    lr.currentSize = 0
    
    return err
}

func (lr *LogRotator) Close() error {
    if lr.currentFile != nil {
        return lr.currentFile.Close()
    }
    return nil
}

// ä½¿ç”¨ç¤ºä¾‹
func logRotatorExample() {
    rotator := NewLogRotator("app.log", 100, 3) // æœ€å¤§100å­—èŠ‚ï¼Œä¿ç•™3ä¸ªæ–‡ä»¶
    defer rotator.Close()
    
    // å†™å…¥å¤§é‡æ—¥å¿—æ•°æ®
    for i := 1; i <= 10; i++ {
        logEntry := fmt.Sprintf("æ—¥å¿—æ¡ç›® %d: è¿™æ˜¯ä¸€æ¡æµ‹è¯•æ—¥å¿—æ¶ˆæ¯ï¼ŒåŒ…å«ä¸€äº›è¯¦ç»†ä¿¡æ¯\n", i)
        rotator.Write([]byte(logEntry))
        time.Sleep(10 * time.Millisecond)
    }
    
    // æ£€æŸ¥ç”Ÿæˆçš„æ—¥å¿—æ–‡ä»¶
    fmt.Println("ç”Ÿæˆçš„æ—¥å¿—æ–‡ä»¶:")
    for i := 0; i <= 3; i++ {
        filename := "app.log"
        if i > 0 {
            filename = fmt.Sprintf("app.log.%d", i)
        }
        
        if info, err := os.Stat(filename); err == nil {
            fmt.Printf("  %s (%d bytes)\n", filename, info.Size())
        }
    }
    
    // æ¸…ç†æ–‡ä»¶
    defer func() {
        for i := 0; i <= 3; i++ {
            filename := "app.log"
            if i > 0 {
                filename = fmt.Sprintf("app.log.%d", i)
            }
            os.Remove(filename)
        }
    }()
}
```

## 7. å®è·µç»ƒä¹ 

### ç»ƒä¹ 1ï¼šæ–‡ä»¶åŒæ­¥å·¥å…·
```go
// å®ç°ä¸€ä¸ªç®€å•çš„æ–‡ä»¶åŒæ­¥å·¥å…·
type FileSyncer struct {
    // æ¯”è¾ƒä¸¤ä¸ªç›®å½•çš„æ–‡ä»¶
    // åŒæ­¥æ–‡ä»¶å·®å¼‚
    // å¤„ç†å†²çª
}

func (fs *FileSyncer) Sync(srcDir, dstDir string) error {
    // å®ç°åŒæ­¥é€»è¾‘
    return nil
}
```

### ç»ƒä¹ 2ï¼šæ–‡ä»¶å‹ç¼©å½’æ¡£
```go
// å®ç°ä¸€ä¸ªæ–‡ä»¶å‹ç¼©å½’æ¡£å·¥å…·
type FileArchiver struct {
    // åˆ›å»ºå‹ç¼©æ–‡ä»¶
    // è§£å‹æ–‡ä»¶
    // åˆ—å‡ºå½’æ¡£å†…å®¹
}

func (fa *FileArchiver) Archive(files []string, archiveName string) error {
    // å®ç°å½’æ¡£é€»è¾‘
    return nil
}
```

### ç»ƒä¹ 3ï¼šé…ç½®æ–‡ä»¶ç®¡ç†å™¨
```go
// å®ç°ä¸€ä¸ªé…ç½®æ–‡ä»¶ç®¡ç†å™¨
type ConfigManager struct {
    // è¯»å–å¤šç§æ ¼å¼çš„é…ç½®æ–‡ä»¶
    // ç›‘æ§é…ç½®æ–‡ä»¶å˜åŒ–
    // çƒ­é‡è½½é…ç½®
}

func (cm *ConfigManager) LoadConfig(filename string) error {
    // å®ç°é…ç½®åŠ è½½é€»è¾‘
    return nil
}
```

## 8. å‚è€ƒèµ„æ–™

- [osåŒ…æ–‡æ¡£](https://golang.org/pkg/os/)
- [ioåŒ…æ–‡æ¡£](https://golang.org/pkg/io/)
- [bufioåŒ…æ–‡æ¡£](https://golang.org/pkg/bufio/)
- [filepathåŒ…æ–‡æ¡£](https://golang.org/pkg/path/filepath/)
- [Goæ–‡ä»¶æ“ä½œæœ€ä½³å®è·µ](https://golang.org/doc/effective_go.html#files)

---

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ å°†å…¨é¢æŒæ¡Goè¯­è¨€ä¸­çš„æ–‡ä»¶å’Œç›®å½•æ“ä½œæŠ€æœ¯ï¼Œèƒ½å¤Ÿé«˜æ•ˆåœ°å¤„ç†å„ç§æ–‡ä»¶ç³»ç»Ÿä»»åŠ¡ï¼ŒåŒ…æ‹¬æ–‡ä»¶è¯»å†™ã€ç›®å½•ç®¡ç†ã€è·¯å¾„å¤„ç†ç­‰æ“ä½œã€‚